---
title: "Logging"
description: "Unified logging API for server and client using build-time conditional exports."
---

Complete guide for using the unified logging system across the monorepo.

## Overview

The monorepo uses a unified logging API (`@repo/utils/logger`) that works consistently across:
- **Server-side**: Fastify API and Next.js server runtime (uses Pino for structured JSON logging)
- **Client-side**: Next.js client components (uses console wrapper with environment-controlled levels)

**Key principles:**
- Single import everywhere: `import { logger } from '@repo/utils/logger'`
- Never use `console.*` directly in app code (enforced by linting)
- Build-time conditional exports select the correct implementation (no runtime detection)
- Structured logging with support for bindings (requestId, userId, etc.)
- Environment-based configuration (enabled/disabled, log levels)
- Automatic secret redaction on server-side

## Architecture

### Build-Time Conditional Exports

The logger uses **build-time conditional exports** via `package.json` exports field. This means:

- **No runtime detection**: No `typeof window`, no `process` checks, no dynamic imports
- **Bundler handles selection**: Next.js, Turbopack, and other bundlers automatically select the correct implementation
- **TypeScript sees unified API**: The `types` field ensures TypeScript always sees one `Logger` interface

**How it works:**

```json
{
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "browser": "./dist/client.js",
      "node": "./dist/server.js",
      "import": "./dist/server.js",
      "default": "./dist/server.js"
    }
  }
}
```

- `browser` condition → routes to `client.js` (Next.js client bundles)
- `node` / `import` / `default` → routes to `server.js` (Node/Fastify/Next.js server)
- `types` → provides unified TypeScript definitions

**Important**: `index.ts` is types-only and never imported at runtime. `server.ts` and `client.ts` are the actual runtime entrypoints that export `logger`.

### Why No Runtime Detection?

Runtime detection (`typeof window`, `process` checks) has several problems:

1. **Bundle size**: Both implementations get bundled, increasing size
2. **Tree-shaking fails**: Bundlers can't eliminate unused code
3. **Edge runtime issues**: Edge runtimes may not have expected globals
4. **Type safety**: TypeScript can't properly narrow types

Build-time conditional exports solve all these issues by letting the bundler choose the correct implementation before bundling.

## Environment Variables

### Server-side (Fastify API, Next.js Server)

| Variable | Type | Default | Description |
|----------|------|---------|-------------|
| `LOG_ENABLED` | boolean | `true` | Enable/disable logging |
| `LOG_LEVEL` | `debug\|info\|warn\|error\|silent` | `info` | Minimum log level |
| `LOG_SERVICE` | string | `"app"` | Service name for log entries |

**Example `.env`:**
```bash
LOG_ENABLED=true
LOG_LEVEL=info
LOG_SERVICE=api
```

### Client-side (Next.js Client Components)

| Variable | Type | Default | Description |
|----------|------|---------|-------------|
| `NEXT_PUBLIC_LOG_ENABLED` | boolean | `true` (dev), `false` (prod) | Enable/disable logging |
| `NEXT_PUBLIC_LOG_LEVEL` | `debug\|info\|warn\|error\|silent` | `debug` (dev), `info` (prod) | Minimum log level |

**Example `.env`:**
```bash
NEXT_PUBLIC_LOG_ENABLED=true
NEXT_PUBLIC_LOG_LEVEL=info
```

**Important**: Client-side logs are disabled in production by default. This means log statements won't execute, improving performance and reducing bundle size.

## Usage

### Server-Side

**Fastify Routes** - Use Fastify's built-in logger (`request.log`) for automatic request context, or create child loggers:

```typescript
// apps/fastify/src/routes/users.ts
import { logger } from '@repo/utils/logger'
import type { FastifyRequest, FastifyReply } from 'fastify'

export async function userRoutes(fastify: FastifyInstance) {
  fastify.get('/users/:id', async (request: FastifyRequest, reply: FastifyReply) => {
    // Option 1: Use Fastify's logger (includes request context automatically)
    request.log.info('Fetching user')
    
    // Option 2: Create child logger with custom context
    const requestLogger = logger.child({ requestId: request.id, userId: request.params.id })
    requestLogger.debug('User details requested')
    
    try {
      const user = await getUserById(request.params.id)
      requestLogger.info({ email: user.email }, 'User fetched')
      return reply.send(user)
    } catch (error) {
      requestLogger.error({ error }, 'Failed to fetch user')
      return reply.code(500).send({ error: 'Internal server error' })
    }
  })
}
```

**Next.js Route Handlers & Server Actions**:

```typescript
// app/api/users/route.ts
import { logger } from '@repo/utils/logger'
import { NextRequest, NextResponse } from 'next/server'

export async function GET(request: NextRequest) {
  const requestLogger = logger.child({ 
    requestId: request.headers.get('x-request-id') || crypto.randomUUID() 
  })
  
  try {
    requestLogger.info('Processing request')
    const users = await getUsers()
    requestLogger.debug({ count: users.length }, 'Users fetched')
    return NextResponse.json(users)
  } catch (error) {
    requestLogger.error({ error }, 'Request failed')
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
```

### Client-Side

**Client Components** - Logs are disabled in production by default (no performance impact):

```typescript
// components/user-profile.tsx
'use client'

import { logger } from '@repo/utils/logger'
import { useEffect, useMemo } from 'react'

export function UserProfile({ userId }: { userId: string }) {
  const componentLogger = useMemo(
    () => logger.child({ component: 'UserProfile', userId }),
    [userId]
  )
  
  useEffect(() => {
    componentLogger.info('Component mounted')
    return () => componentLogger.debug('Component unmounted')
  }, [componentLogger])
  
  const handleClick = () => {
    componentLogger.info('User profile clicked')
  }
  
  return <div onClick={handleClick}>...</div>
}
```

## Log Levels

Use appropriate log levels:

- **`debug`**: Detailed information for debugging (development only)
- **`info`**: General informational messages
- **`warn`**: Warning messages for potentially harmful situations
- **`error`**: Error messages for failures
- **`silent`**: Disable all logging

```typescript
logger.debug('Detailed debug information', { data })
logger.info('User logged in', { userId })
logger.warn('Rate limit approaching', { remaining: 10 })
logger.error('Database connection failed', { error })
```

## Best Practices

**1. Use Structured Fields** - Always use structured fields instead of string interpolation:

```typescript
// ✅ Good
logger.info({ userId, action: 'login' }, 'User logged in')

// ❌ Bad
logger.info(`User ${userId} logged in`)
```

**2. Request Correlation** - Use `child()` to create request-scoped loggers:

```typescript
const requestLogger = logger.child({ requestId, userId })
requestLogger.info('Processing request') // Includes requestId and userId
```

**3. Secret Redaction** - Server-side logger automatically redacts: `password`, `token`, `secret`, `key`, `apiKey`, `accessToken`, `refreshToken`, `authorization`, `cookie`, `session`

**4. Error Logging** - Always include error objects:

```typescript
try {
  await processOrder(orderData)
} catch (error) {
  logger.error({ error, context: { userId, orderId } }, 'Failed to process order')
  throw error
}
```

**5. Integration with `@repo/error`** - When using `captureError` in Fastify, pass `request.log` to use Fastify's native logger:

```typescript
import { captureError, mapHttpStatusToErrorCode } from '@repo/error/node'

fastify.setErrorHandler((error, request, reply) => {
  const catalogError = captureError({
    code: mapHttpStatusToErrorCode(error.statusCode),
    error,
    logger: request.log, // Uses Fastify's logger with request context
    label: `${request.method} ${request.url}`,
  })
  reply.status(error.statusCode ?? 500).send(catalogError)
})
```

## Troubleshooting

**Logs not appearing:**
- Check `LOG_ENABLED` / `NEXT_PUBLIC_LOG_ENABLED` environment variables
- Verify log level isn't higher than message level
- Remember: client logs disabled in production by default

**Console usage linting errors:**
- Ensure importing from `@repo/utils/logger` (not `console.*`)
- Only `packages/utils/logger/src/client.ts` can use `console.*`

**Pino in client bundles:**
- Verify `package.json` exports include `browser` condition
- Check `client.ts` never imports `pino`
- Inspect bundle analysis with `next build`

## Related Documentation

- [Installation](/docs/getting-started/installation) - Environment variable configuration
- [Error Handling](/docs/architecture/error-handling) - Error logging with `@repo/error`
