---
title: "Environment Strategy"
description: "Guide to environment variable management across the monorepo, including environment-specific configuration files and loading priorities."
---

This document describes the environment variable strategy across the monorepo, including how environment-specific configurations are loaded and used.

## Overview

We use environment-specific configuration files to separate local development, staging, and production environments. Each environment maps to appropriate blockchain networks and deployment targets.

## Environment Files

### Vencura API (`apps/api` - Elysia backend)

Environment files are loaded in priority order:

1. **`.env`** (highest priority, sensitive data, never committed, overrides everything)
2. **`.env.<NODE_ENV>`** (development/staging/production/test, committed configs)

### Next.js Apps (`apps/web`, `apps/mathler`)

Next.js automatically loads environment files in priority order:

1. **`.env.local`** (highest priority, never committed)
2. **`.env.development`** / **`.env.production`** / **`.env.test`** (based on NODE_ENV)
3. **`.env`** (fallback, lowest priority)

## Environment Matrix

| Environment | NODE_ENV      | Env File           | Blockchain Network                   | Use Case                      |
| ----------- | ------------- | ------------------ | ------------------------------------ | ----------------------------- |
| Local Dev   | `development` | `.env.development` | Testnets (Arbitrum Sepolia)          | Local development and testing |
| Staging     | `staging`     | `.env.staging`     | Testnets (Sepolia, Arbitrum Sepolia) | Pre-production validation     |
| Production  | `production`  | `.env.production`  | Mainnet (real chains)                | Live production environment   |
| Test        | `test`        | `.env.test`        | Testnets (Arbitrum Sepolia)          | CI/CD and automated tests     |

## Environment Variables

### Required Variables

**Vencura API (Elysia backend):**

- `DYNAMIC_ENVIRONMENT_ID` - Dynamic Labs environment ID
- `DYNAMIC_API_TOKEN` - Dynamic Labs API token
- `ENCRYPTION_KEY` - Encryption key (32+ characters)

**Next.js Apps:**

- `NEXT_PUBLIC_DYNAMIC_ENVIRONMENT_ID` - Dynamic Labs environment ID (optional, but recommended)

### Optional Variables

**Vencura API (Elysia backend):**

- `PORT` - Server port (default: 3077)
- `RPC_URL_<CHAIN_ID>` - Per-chain RPC URL overrides (e.g., `RPC_URL_421614`, `RPC_URL_84532`)
- `ARBITRUM_SEPOLIA_RPC_URL` - Legacy Arbitrum Sepolia RPC URL (backward compatibility)
- `SOLANA_RPC_URL` - Solana RPC URL
- `OPEN_AI_KEY` - OpenAI API key for AI features
- `SENTRY_DSN` - Sentry error tracking DSN
- `SENTRY_ENVIRONMENT` - Sentry environment name
- `ENABLE_SWAGGER_UI` - Enable Swagger UI (default: `false`)
- `ARB_TESTNET_GAS_FAUCET_KEY` - Testnet faucet private key (for automated funding in E2E tests)

**Next.js Apps:**

- `NEXT_PUBLIC_API_URL` - Vencura API URL (default: `http://localhost:3077`)
- `NEXT_PUBLIC_SENTRY_DSN` - Sentry error tracking DSN
- `NEXT_PUBLIC_SENTRY_ENVIRONMENT` - Sentry environment name

## RPC URL Pattern

We use a consistent pattern for RPC URLs:

- **Format**: `RPC_URL_<CHAIN_ID>` or `RPC_URL_<DYNAMIC_NETWORK_ID>`
- **Examples**:
  - `RPC_URL_421614` - Arbitrum Sepolia (chain ID: 421614)
  - `RPC_URL_84532` - Base Sepolia (chain ID: 84532)
  - `RPC_URL_42161` - Arbitrum Mainnet (chain ID: 42161)
  - `RPC_URL_8453` - Base Mainnet (chain ID: 8453)

## Environment Validation

All apps enforce **Zod-validated** environment configuration objects using Zod schemas and `@vencura/lib` utilities. See [ADR 014: Environment Strategy](/docs/adrs/014-environment-strategy) for the complete architecture decision. This ensures:

- **Type safety**: Full TypeScript inference from Zod schemas (`z.infer<typeof envSchema>`)
- **Fail fast**: Invalid config causes immediate failure at module load with clear error messages
- **DX-focused**: Fast failure, clear error messages, no manual error checks needed
- **Portable**: Works consistently across all environments (development, staging, production, test)

## Setup Instructions

### Local Development

1. Copy the appropriate example file:

   ```bash
   cd apps/api
   cp .env.development.example .env.development
   # Or for Next.js apps:
   cd apps/web
   cp .env.development.example .env.local
   ```

2. Fill in your values (Dynamic environment ID, API token, etc.)

3. Start development:

   ```bash
   # From monorepo root
   bun run dev:local

   # Or start apps individually
   cd apps/api && bun run dev
   cd apps/web && bun run dev
   ```

### Staging

1. Copy the staging example file:

   ```bash
   cd apps/api
   cp .env.staging.example .env.staging
   ```

2. Fill in staging values (testnet RPC URLs, staging Dynamic environment ID, etc.)

3. Configure in Vercel dashboard:
   - Go to Project Settings → Environment Variables
   - Add variables for `develop` branch (staging environment)
   - Use testnet RPC URLs

4. Deploy:
   ```bash
   git checkout develop
   git push origin develop
   # Vercel automatically deploys to Preview with staging env
   ```

### Production

1. Copy the production example file:

   ```bash
   cd apps/api
   cp .env.production.example .env.production
   ```

2. Fill in production values (mainnet RPC URLs, production Dynamic environment ID, etc.)

3. Configure in Vercel dashboard:
   - Go to Project Settings → Environment Variables
   - Add variables for `main` branch (production environment)
   - Use mainnet RPC URLs

4. Deploy:
   ```bash
   git checkout main
   git push origin main
   # Vercel automatically deploys to Production with production env
   ```

## Testing

Tests use `.env.test` with local Anvil blockchain:

1. Copy the test example file:

   ```bash
   cd apps/api
   cp .env.test.example .env.test
   ```

2. Fill in test values

3. Run tests:
   ```bash
   cd apps/api
   bun run test:e2e
   ```

## CI/CD

GitHub Actions workflows automatically:

- Use `.env.test` configuration
- Tests run against Arbitrum Sepolia testnet
- Automated gas funding via `ARB_TESTNET_GAS_FAUCET_KEY`

No manual configuration needed for CI/CD.

## Environment Validation

All apps enforce validated environment configuration objects using Zod schemas and `@vencura/lib` utilities.

### Pattern

**Next.js Apps:**
- Use `getEnvHelper` from `@vencura/lib`
- Export `zEnv` as const object: `export const zEnv = getEnv()`
- Validation happens at module load (build time for `NEXT_PUBLIC_*` vars)

**Server Apps (Vencura API - Elysia backend):**
- Use Bun's built-in `.env` file loading (no manual loading needed)
- Export `environment` object that reads directly from `process.env`
- Provides TypeScript type safety via Zod schema (no runtime validation)

### Usage Example

**Next.js Apps:**
```typescript
// apps/web/src/lib/env.ts
import { z } from 'zod'
import { getEnvHelper } from '@vencura/lib'

const envSchema = z.object({
  NEXT_PUBLIC_API_URL: z.string().url().optional(),
  PORT: z.coerce.number().optional().default(3000),
})

export type Env = z.infer<typeof envSchema>

export function getEnv(): Env {
  return getEnvHelper({ schema: envSchema })
}

export const zEnv = getEnv()
```

**Elysia API:**
```typescript
// apps/api/src/lib/env.ts
import { z } from 'zod'

const envSchema = z.object({
  DYNAMIC_ENVIRONMENT_ID: z.string().min(1),
  DYNAMIC_API_TOKEN: z.string().min(1),
  PORT: z.coerce.number().optional().default(3077),
})

export type Env = z.infer<typeof envSchema>

// Bun automatically loads .env files
export const environment = {
  DYNAMIC_ENVIRONMENT_ID: process.env.DYNAMIC_ENVIRONMENT_ID ?? '',
  DYNAMIC_API_TOKEN: process.env.DYNAMIC_API_TOKEN ?? '',
  PORT: Number(process.env.PORT) || 3077,
} as const satisfies Env
```

### Using Environment Variables in Code

**Next.js Apps:**
```typescript
// Instead of process.env.PORT
import { zEnv } from './lib/env'
const port = zEnv.PORT

// Zod handles type coercion and validation
// No manual error checks needed
```

**Elysia API:**
```typescript
// Instead of process.env.PORT
import { environment } from './lib/env'
const port = environment.PORT

// Type-safe access via TypeScript
// Bun handles .env file loading automatically
```

## Best Practices

1. **Never commit `.env.local`** - It's in `.gitignore` and contains sensitive secrets
2. **Use `.env.example` files** - Commit example files for reference
3. **Environment-specific configs** - Use `.env.development`, `.env.staging`, `.env.production` for environment-specific values
4. **Local overrides** - Use `.env.local` for local-only overrides (highest priority)
5. **RPC URL pattern** - Use `RPC_URL_<CHAIN_ID>` pattern for consistency
6. **Always use typed env objects** - Import `zEnv` (Next.js) or `environment` (Elysia API) from `lib/env.ts` instead of accessing `process.env` directly
7. **Leverage @vencura/lib** - Use `getEnvHelper` for Next.js apps - no custom validation logic needed
8. **Elysia API** - Use Bun's built-in `.env` loading, no manual loading or validation required
8. **Zod schemas** - Use `z.coerce.number()`, `z.optional()`, `z.default()` for proper type handling
9. **Zod-first validation** - All environment variables validated with Zod for type safety and clear error messages

