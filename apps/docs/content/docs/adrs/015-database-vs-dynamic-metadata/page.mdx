---
title: "ADR 015: Database Storage vs Dynamic SDK Metadata"
description: "When building the Vencura API, we needed to decide where to store wallet and user data. Dynamic SDK provides some metadata capabilities, but we needed to understand what data should be stored in our own database versus what can be stored in Dynamic's infrastructure."
---

# ADR 015: Database Storage vs Dynamic SDK Metadata

## Status

Accepted

## Context

When building the Vencura API, we needed to decide where to store wallet and user data. Dynamic SDK provides some metadata capabilities, but we needed to understand what data should be stored in our own database versus what can be stored in Dynamic's infrastructure.

### Dynamic SDK Capabilities

Dynamic SDK offers two types of metadata:

1. **User Metadata** (Frontend-only):
   - Available via React SDK hook `useUserUpdateRequest()`
   - Can store arbitrary JSON data associated with users
   - Only accessible from client-side React components
   - Not available via backend node SDK (`@dynamic-labs-wallet/node-evm` or `@dynamic-labs-wallet/node-svm`)

2. **Wallet Metadata** (Not supported):
   - Dynamic SDK's node wallet clients do not support custom wallet metadata
   - Only expose wallet operations: `createWalletAccount()`, `signMessage()`, `signTransaction()`
   - No methods for storing or retrieving custom wallet metadata

### Our Data Requirements

We need to store:

- **Wallet Data**:
  - Wallet ID (our UUID)
  - User ID (association with our users)
  - Wallet address
  - Encrypted server-side key shares
  - Network/chain type information
  - Creation timestamp

- **User Data**:
  - User ID
  - Email
  - Creation timestamp

- **Operational Requirements**:
  - Backend needs to query wallets by `userId`
  - Backend needs to retrieve encrypted key shares for signing operations
  - Backend needs to verify wallet ownership before operations
  - All wallet operations require database lookups

## Decision

We will store all wallet and user data in our own database (PostgreSQL/PGLite) rather than relying on Dynamic SDK metadata.

### What We Store in Our Database

**`wallets` table:**

- `id` - UUID primary key (generated locally)
- `userId` - Foreign key to `users` table
- `address` - Wallet address (from Dynamic SDK's `accountAddress`)
- `privateKeyEncrypted` - Encrypted server-side key shares (from Dynamic SDK's `externalServerKeyShares`)
- `network` - Dynamic network ID string (e.g., `'421614'`, `'solana-mainnet'`)
- `chainType` - Chain type enum (`'evm'`, `'solana'`, etc.)
- `createdAt` - Timestamp

**`users` table:**

- `id` - UUID primary key
- `email` - User email
- `createdAt` - Timestamp

### What Dynamic SDK Stores/Manages

**Dynamic SDK returns when creating a wallet:**

- `accountAddress` - Wallet address (stored in our DB as `address`)
- `externalServerKeyShares` - Server-side key shares (encrypted and stored in our DB as `privateKeyEncrypted`)

**Dynamic SDK manages internally (not stored in our DB):**

- Client-side key share (managed by Dynamic SDK's infrastructure)
- Threshold signature scheme configuration (2-of-2)
- Wallet recovery/backup metadata (we set `backUpToClientShareService: false`)
- Dynamic's internal wallet metadata and associations
- Wallet state and transaction history (queried via SDK, not stored locally)

## Rationale

### Why Not Use Dynamic User Metadata?

1. **Backend Operations Require Database**:
   - Our API needs to query wallets by `userId` (e.g., `getUserWallets()`)
   - Dynamic's backend SDK doesn't expose user metadata APIs
   - Wallet operations (balance, sign, send) need wallet lookups

2. **User Metadata is Frontend-Only**:
   - `useUserUpdateRequest()` only works in React components
   - Our backend can't read/write user metadata
   - We'd need to proxy metadata updates through the frontend

3. **Wallet Associations**:
   - We need to associate wallets with users
   - Dynamic doesn't expose wallet-to-user mappings in their backend API
   - We'd still need to store `userId` → `walletId` mappings

### Why Database is the Right Choice

1. **Backend Needs Direct Access**:
   - All wallet operations require database queries
   - Need to verify wallet ownership before operations
   - Need to retrieve encrypted key shares for signing

2. **Query Requirements**:
   - Query wallets by user ID
   - Query wallets by network/chain type
   - Filter and sort wallets

3. **Security**:
   - Encrypted key shares stored securely in our database
   - Full control over encryption and access patterns
   - User isolation enforced at database level

4. **Operational Control**:
   - Full control over data schema and migrations
   - Can optimize queries for our use cases
   - Can add indexes and constraints as needed

## When to Use Dynamic User Metadata

Dynamic user metadata can be used for:

- **Frontend-only data**: Data that doesn't need backend access
- **User preferences**: Settings that can be managed entirely client-side
- **Application state**: Game history, UI preferences, etc. (like Mathler's game history)

**Example from Mathler app:**

```typescript
// Frontend-only game history stored in Dynamic user metadata
const { updateUser } = useUserUpdateRequest()

await updateUser({
  metadata: {
    mathlerHistory: [...gameHistory],
  },
})
```

## Consequences

### Positive

- ✅ Full control over data storage and access patterns
- ✅ Backend can efficiently query and filter wallets
- ✅ Secure storage of encrypted key shares
- ✅ User isolation enforced at database level
- ✅ Can optimize database schema for our use cases
- ✅ No dependency on Dynamic SDK metadata APIs

### Negative

- ❌ Need to maintain our own database infrastructure
- ❌ Need to handle database migrations and schema changes
- ❌ Additional operational overhead compared to using Dynamic metadata

### Neutral

- Frontend apps can still use Dynamic user metadata for frontend-only data
- We maintain separation: backend data in database, frontend-only data in Dynamic metadata

## Implementation Notes

### Database Schema

```typescript
// wallets table
export const wallets = pgTable('wallets', {
  id: text('id').primaryKey(),
  userId: text('user_id')
    .notNull()
    .references(() => users.id),
  address: text('address').notNull(),
  privateKeyEncrypted: text('private_key_encrypted').notNull(),
  network: text('network').notNull(), // Dynamic network ID
  chainType: text('chain_type').notNull(), // 'evm', 'solana', etc.
  createdAt: timestamp('created_at').defaultNow().notNull(),
})

// users table
export const users = pgTable('users', {
  id: text('id').primaryKey(),
  email: text('email').notNull(),
  createdAt: timestamp('created_at').defaultNow().notNull(),
})
```

### Wallet Creation Flow

1. Dynamic SDK generates wallet → Returns `accountAddress` and `externalServerKeyShares`
2. Encrypt key shares → Store encrypted in database
3. Store wallet metadata → Store address, network, chainType, userId in database
4. Return wallet info → Return our wallet ID, address, network, chainType

### Query Patterns

All wallet queries include user isolation:

```typescript
// Query wallets for a user
const wallets = await db.select().from(schema.wallets).where(eq(schema.wallets.userId, userId))

// Query specific wallet with user isolation
const [wallet] = await db
  .select()
  .from(schema.wallets)
  .where(
    and(
      eq(schema.wallets.id, walletId),
      eq(schema.wallets.userId, userId), // User isolation
    ),
  )
```

## References

- [Dynamic Integration Architecture](/docs/dynamic-integration)
- [Vencura API](/docs/apps/api)
