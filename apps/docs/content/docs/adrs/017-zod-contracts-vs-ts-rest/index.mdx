---
title: "ADR 017: Zod-First Contracts vs ts-rest Adoption"
description: "Decision to implement a Zod-first contract layer inspired by ts-rest rather than adopting ts-rest as a dependency, maintaining flexibility and control while avoiding framework lock-in."
---

## Status

Accepted

## Context

We are building a Bun/Elysia API and a Next.js frontend. Our goals:

* Keep a **single source of truth** for API shapes: request validation + response typing.
* Avoid **generated code** and keep DX ergonomic with strong TypeScript inference.
* Minimize framework lock-in and keep the architecture **maintainable long term**.
* Produce **OpenAPI** artifacts for documentation and interoperability.
* Support an “AI era” architecture where we may also expose capabilities via **MCP tools** (agent-facing), without rewriting validation logic.

We evaluated two approaches:

1. **Adopt ts-rest** end-to-end (contracts + server adapter + client integrations).
2. Implement a **Zod-first contract layer** inspired by ts-rest (“ts-rest-like”), using:

   * Zod schemas as truth
   * a small `Contract` type + `defineContract()` helper
   * a tiny Elysia adapter helper `registerRoute(contract, handler)`
   * OpenAPI metadata typed using standard OpenAPI types (`openapi-types`)
   * a single global error handler (`.onError`) and typed domain errors

## Decision

We will implement and standardize on a **Zod-first contract layer** (ts-rest-like), and **not** depend on ts-rest as a core runtime dependency.

We will keep the design compatible with ts-rest concepts so we can optionally:

* adopt ts-rest client ergonomics later, or
* migrate to ts-rest fully if the project’s maintenance and Bun/Elysia adapter story becomes stronger.

## Rationale

Because Elysia has no official ts-rest adapter, we would need to write and maintain an adapter regardless. In that case, adopting the entire ts-rest stack provides limited incremental benefit while increasing dependency and long-term risk.

A Zod-first contract approach keeps the system simple, preserves full type safety, avoids codegen, and aligns with our desire for future "AI era" compatibility (OpenAPI artifacts + potential MCP tool definitions) without coupling to a specific library's roadmap.

## Alternatives Considered

### Alternative 1: Adopt ts-rest end-to-end

Use ts-rest’s contract definitions, server adapter packages, client packages, and OpenAPI tooling.

**Pros**

* Strong “contract-first” story out of the box (types + runtime validation + clients).
* Existing integrations (e.g., React Query integration in ts-rest ecosystem).
* OpenAPI generation support via `@ts-rest/open-api`.

**Cons**

* No official Elysia server adapter; we would still need to build/maintain an adapter.
* Adds dependency surface area and upgrades/compatibility risk across multiple packages.
* Long-term maintenance cadence is uncertain relative to foundation-backed frameworks/libs.
* Our architecture would be more coupled to ts-rest idioms than necessary.

### Alternative 2: Zod-first contracts (ts-rest-like)

Define a small contract object: `{ method, path, body?, response, openapi?, mcp? }` using Zod schemas, plus helper utilities:

* `defineContract()` for inference
* `registerRoute(app, contract, handler)` for Elysia
* dev-only response validation (optional) for safety without production overhead
* standard OpenAPI meta typing (`openapi-types`)
* domain errors + one global `.onError`

**Pros**

* Minimal abstraction: Zod is the only “core” dependency for validation/inference.
* Works naturally with Elysia’s Zod-based validation and OpenAPI `detail`.
* Maximum control and low lock-in; the contract objects remain plain data.
* Easy to evolve toward MCP tooling by reusing the same schemas.
* Smaller dependency footprint and less “framework glue” long term.
* No code generation and no requirement to standardize on any specific client library.

**Cons**

* We must maintain a small adapter layer (`registerRoute`) and associated typings.
* We must implement a small amount of convenience functionality ts-rest already provides
  (e.g., richer error response modeling, query/params schema support, helpers).
* If we want advanced features (multi-status response typing, content-type negotiation),
  we'll need to extend our contract model carefully.

## Consequences

### Positive

- ✅ Contracts are lightweight, stable, and easy to share between packages (`packages/types`)
- ✅ API routes become minimal with boilerplate removed via `registerRoute()` and global `.onError`
- ✅ Generate OpenAPI artifacts consistently without duplicating schema definitions
- ✅ Add MCP "tool metadata" alongside OpenAPI metadata without restructuring
- ✅ Choose any fetch client strategy (TanStack Query + fetch wrapper) without codegen
- ✅ Minimal abstraction with Zod as the only core dependency for validation/inference
- ✅ Maximum control and low framework lock-in

### Negative

- ❌ We own the adapter layer and must maintain it across Elysia upgrades
- ❌ Contract model must be extended intentionally as needs grow (params/query/headers, multi-status responses, auth/security metadata)
- ❌ Without careful guardrails, teams might diverge in contract definitions
- ❌ Must implement convenience functionality that ts-rest already provides

### Neutral

- Mitigations in place: contract model kept minimal via `defineContract()`, shared patterns for domain errors, automated tests for `registerRoute` and OpenAPI generation
- Contract package will be versioned carefully and treated as core API surface

## Implementation Notes

### Contract Type System

Create `packages/types/src/contracts/contract.ts` with:

- `Contract` type
- `defineContract()` helper for type inference
- `InferBody`, `InferResponse` type utilities
- `OperationMeta` typed using `openapi-types` (`Pick<OpenAPIV3.OperationObject, ...>`)

### Elysia Adapter

Add `apps/api/src/http/register-route.ts` with:

- `registerRoute(app, contract, handler, options)` helper
- Dev-only response validation via `contract.response.parse()`

### Error Handling

Add `apps/api/src/http/error-plugin.ts` with:

- `AppError` base class
- `.error({ APP_ERROR: AppError })` registration
- Single global `.onError` mapping for consistent error responses

### Contract Organization

- Standardize contracts in `packages/types/src/contracts/**`
- Standardize schema definitions in `packages/types/src/schemas/**`

### Future Extensions

- Extend contract support for `params`, `query`, `headers` (Zod schemas + inferred handler ctx)
- Decide on multi-status response typing (e.g., `{ 200: zod, 404: zod }`) vs "success returns" + thrown errors
- Add `toMcpTools(contracts)` helper to map contract metadata and schemas into MCP tool descriptors (artifact-only, no codegen)

## Related ADRs

- [ADR 002: Vencura API Framework](/docs/adrs/002-vencura-api-framework) - Elysia framework decision
- [ADR 012: Vencura AI Architecture](/docs/adrs/012-vencura-ai-architecture) - MCP tools and AI-era architecture

## References

- [Zod Documentation](https://zod.dev)
- [Elysia Documentation](https://elysiajs.com)
- [ts-rest Documentation](https://ts-rest.com)
- [OpenAPI Types](https://www.npmjs.com/package/openapi-types)
