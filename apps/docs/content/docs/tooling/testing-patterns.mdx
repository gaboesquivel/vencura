---
title: "Testing Patterns"
description: "Vitest blackbox testing strategy for the Vencura monorepo."
---

This guide codifies the **blackbox, real-API testing strategy** used across the Vencura monorepo. Tests always exercise public interfaces (HTTP endpoints, public hooks, exported clients) and interact with real APIs, SDKs, and blockchains whenever feasible.

## Testing Philosophy

- **Blackbox first**: Hit HTTP endpoints or exported functions instead of internal helpers.
- **Real APIs + real keys**: Use real Dynamic SDK endpoints and RPCs (local Anvil for tests) with secrets supplied via environment variables.
- **E2E bias**: Favor integration/E2E coverage over unit tests; validate full request/response contracts.
- **No mocks for core flows**: Only mock UI-specific APIs (window, storage) or timers where necessary.

## Elysia Route Testing (Blackbox)

Use `app.handle()` helpers (e.g., `testRoute`) to exercise each route through HTTP semantics.

### Basic Route Test

```typescript
import { describe, it, expect } from 'vitest'
import { Elysia } from 'elysia'
import { helloRoute } from '../routes/hello'
import { testRoute } from '../test/utils/elysia'

describe('helloRoute', () => {
  it('should return hello message via HTTP endpoint', async () => {
    const response = await testRoute(helloRoute, {
      method: 'GET',
      path: '/hello',
    })
    const data = await response.json()

    expect(response.status).toBe(200)
    expect(data).toEqual({ message: 'Hello, World!' })
  })
})
```

### Route with Request Body

```typescript
import { describe, it, expect } from 'vitest'
import { createWalletRoute } from '../routes/wallets'
import { testRoute } from '../test/utils/elysia'

describe('createWalletRoute', () => {
  it('should create wallet via HTTP endpoint', async () => {
    const response = await testRoute(createWalletRoute, {
      method: 'POST',
      path: '/wallets',
      body: {
        chainId: 421614,
        userId: 'test-user-123',
      },
    })

    expect(response.status).toBe(201)
    const data = await response.json()
    expect(data).toHaveProperty('walletId')
    expect(data.chainId).toBe(421614)
  })
})
```

### Route with Headers

```typescript
import { describe, it, expect } from 'vitest'
import { getWalletRoute } from '../routes/wallets'
import { testRoute } from '../test/utils/elysia'

describe('getWalletRoute', () => {
  it('should return wallet with authentication', async () => {
    const response = await testRoute(getWalletRoute, {
      method: 'GET',
      path: '/wallets/wallet-123',
      headers: {
        Authorization: 'Bearer test-token',
      },
    })

    expect(response.status).toBe(200)
    const data = await response.json()
    expect(data).toHaveProperty('address')
  })
})
```

## Zod Schema Validation Testing

Validate schemas with representative valid and invalid payloads to guarantee runtime safety.

### Schema Parsing Test

```typescript
import { describe, it, expect } from 'vitest'
import { z } from 'zod'
import { WalletSchema } from '@vencura/types'

describe('WalletSchema', () => {
  it('should parse valid wallet data', () => {
    const validData = {
      id: 'wallet-123',
      address: '0x1234567890123456789012345678901234567890',
      chainId: 421614,
    }

    const result = WalletSchema.parse(validData)
    expect(result.id).toBe('wallet-123')
    expect(result.address).toBe(validData.address)
  })

  it('should reject invalid wallet data', () => {
    const invalidData = {
      id: 'wallet-123',
      address: 'invalid-address',
      chainId: 421614,
    }

    expect(() => WalletSchema.parse(invalidData)).toThrow()
  })

  it('should provide clear error messages', () => {
    const invalidData = {
      id: 'wallet-123',
      address: 'invalid-address',
      chainId: 'not-a-number',
    }

    const result = WalletSchema.safeParse(invalidData)
    expect(result.success).toBe(false)
    if (!result.success) {
      expect(result.error.issues).toHaveLength(2)
    }
  })
})
```

### Schema Transformation Test

```typescript
import { describe, it, expect } from 'vitest'
import { z } from 'zod'

const UserSchema = z.object({
  email: z.string().email().transform((val) => val.toLowerCase()),
  name: z.string().min(1),
})

describe('UserSchema', () => {
  it('should transform email to lowercase', () => {
    const result = UserSchema.parse({
      email: 'Test@Example.COM',
      name: 'Test User',
    })

    expect(result.email).toBe('test@example.com')
  })
})
```

## React Hooks Testing (Real APIs)

React hooks interact with live APIs via TanStack Query. Never mock query clients or requestsâ€”instantiate a fresh `QueryClient` per test suite.

### Basic Hook Test

```typescript
import { describe, it, expect, beforeEach } from 'vitest'
import { renderHook, waitFor } from '@testing-library/react'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { useWallets } from './use-wallets'

describe('useWallets', () => {
  let queryClient: QueryClient

  beforeEach(() => {
    queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          retry: false,
        },
      },
    })
  })

  it('should fetch wallets from real API', async () => {
    const wrapper = ({ children }) => (
      <QueryClientProvider client={queryClient}>
        {children}
      </QueryClientProvider>
    )

    const { result } = renderHook(() => useWallets(), { wrapper })

    await waitFor(() => expect(result.current.isSuccess).toBe(true))
    expect(result.current.data).toBeDefined()
    expect(Array.isArray(result.current.data)).toBe(true)
  })
})
```

### Hook with Parameters

```typescript
import { describe, it, expect, beforeEach } from 'vitest'
import { renderHook, waitFor } from '@testing-library/react'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { useWallet } from './use-wallet'

describe('useWallet', () => {
  let queryClient: QueryClient

  beforeEach(() => {
    queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          retry: false,
        },
      },
    })
  })

  it('should fetch specific wallet from real API', async () => {
    const wrapper = ({ children }) => (
      <QueryClientProvider client={queryClient}>
        {children}
      </QueryClientProvider>
    )

    const { result } = renderHook(() => useWallet('wallet-123'), { wrapper })

    await waitFor(() => expect(result.current.isSuccess).toBe(true))
    expect(result.current.data).toBeDefined()
    expect(result.current.data?.id).toBe('wallet-123')
  })
})
```

## Core Client Function Testing

Public SDKs (`@vencura/core`, etc.) must be validated against real endpoints (local or staging) with authentic API keys supplied through environment variables.

### API Client Test

```typescript
import { describe, it, expect, beforeAll } from 'vitest'
import { createVencuraClient } from '@vencura/core'

describe('VencuraClient', () => {
  let client: ReturnType<typeof createVencuraClient>

  beforeAll(() => {
    const apiKey = process.env.VENCURA_API_KEY
    if (!apiKey) {
      throw new Error('VENCURA_API_KEY environment variable required')
    }
    client = createVencuraClient({
      apiKey,
      baseUrl: process.env.VENCURA_API_URL || 'http://localhost:3077',
    })
  })

  it('should create wallet via real API', async () => {
    const result = await client.wallets.create({
      chainId: 421614,
      userId: 'test-user-123',
    })

    expect(result).toHaveProperty('walletId')
    expect(result.chainId).toBe(421614)
  })

  it('should handle API errors correctly', async () => {
    await expect(
      client.wallets.create({
        chainId: 999999,
        userId: 'test-user-123',
      }),
    ).rejects.toThrow()
  })
})
```

### Error Handling Test

```typescript
import { describe, it, expect } from 'vitest'
import { createVencuraClient } from '@vencura/core'

describe('VencuraClient error handling', () => {
  it('should validate response with Zod schema', async () => {
    const client = createVencuraClient({
      apiKey: 'test-key',
      baseUrl: 'http://localhost:3077',
    })

    const originalFetch = global.fetch
    global.fetch = async () => {
      return new Response(JSON.stringify({ invalid: 'data' }), {
        status: 200,
        headers: { 'Content-Type': 'application/json' },
      })
    }

    await expect(client.wallets.get('wallet-123')).rejects.toThrow()

    global.fetch = originalFetch
  })
})
```

## Component Testing (Real APIs)

Rendering tests should drive real TanStack Query fetches. Mock only browser-specific APIs when required.

### Component with Real API

```typescript
import { describe, it, expect, beforeEach } from 'vitest'
import { render, screen } from '@testing-library/react'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { WalletList } from './wallet-list'

describe('WalletList', () => {
  let queryClient: QueryClient

  beforeEach(() => {
    queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          retry: false,
        },
      },
    })
  })

  it('should fetch and display wallets from real API', async () => {
    render(
      <QueryClientProvider client={queryClient}>
        <WalletList />
      </QueryClientProvider>,
    )

    const wallets = await screen.findAllByRole('listitem')
    expect(wallets.length).toBeGreaterThan(0)
  })
})
```

## Best Practices

1. **Use real APIs** whenever possible.
2. **Treat tests as blackbox** by interacting through HTTP endpoints or exported hooks.
3. **Wait for async work** using `waitFor`/`findBy`.
4. **Assert error handling** with real failure cases.
5. **Cover loading states** to ensure UX feedback.
6. **Isolate test state** (fresh query clients, env resets).
7. **Clean up** query clients or globals between tests.
8. **Rely on environment helpers** instead of raw `process.env`.
9. **Document intent** with inline comments for complex flows.

## Mocking Guidelines

### When to Mock

- Pure UI behavior (render-only snapshots, animations).
- Browser APIs such as `window`, `localStorage`, `sessionStorage`.
- Timers (`setTimeout`, `setInterval`) when deterministic timing is required.

### When NOT to Mock

- API calls in integration tests.
- TanStack Query hooks and caches.
- Authentication/session flows.
- Data fetching utilities.
- Blockchain RPC calls.

## Running Tests

```bash
# Run all tests
bun run test

# Watch mode
bun run test:watch

# Vitest UI
bun run test:ui

# Coverage
bun run test:cov
```

