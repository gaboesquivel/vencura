# Google Cloud Deployment Option

This document describes the Google Cloud deployment option for the Vencura API, providing enhanced control, security, and extensibility for production workloads.

**Status**: Documented but not currently implemented. See [Vercel Portability Strategy](/docs/vercel-portability) for current deployment approach.

## Overview

Google Cloud Platform provides enhanced security features for production workloads requiring strict data governance:

- Private networking with VPC isolation
- HSM-backed key custody and KMS
- Fine-grained IAM controls
- Enhanced audit logging and compliance
- Private IP database connections

## When to Use Google Cloud

Consider Google Cloud deployment when production security requirements demand:

- Regulatory/compliance requirements for HSM-backed key custody
- Need for MPC/threshold signing workflows
- Requirement for private networking and strict egress control
- Enhanced audit trails and compliance beyond Vercel's capabilities
- Enterprise security requirements that exceed Vercel's offerings

## Architecture

### Infrastructure Components

- **Cloud Run**: Serverless container platform for running the NestJS API
- **Cloud SQL Postgres**: Managed PostgreSQL database with private IP
- **VPC Network**: Dedicated VPC for network isolation
- **VPC Connector**: Serverless VPC access for Cloud Run to connect to Cloud SQL
- **Secret Manager**: Secure storage for API keys, encryption keys, and database credentials
- **Artifact Registry**: Docker image repository
- **Cloudflare**: DDoS protection, SSL/TLS termination, and custom domain management

### Network Topology

```
Internet → Cloudflare → Cloud Run → VPC Connector → Cloud SQL (Private IP)
```

All database connections use private IP addresses only, ensuring no public exposure.

## Security Architecture

### Defense in Depth

Google Cloud deployment implements multiple layers of security:

1. **Authentication Layer**: Dynamic Labs JWT-based authentication
2. **Application Layer**: User isolation and authorization checks
3. **Encryption Layer**: AES-256-GCM encryption for private keys
4. **Database Layer**: Cloud SQL encryption at rest, private IP only
5. **Network Layer**: VPC isolation, private IP only
6. **Infrastructure Layer**: Least privilege IAM, service accounts
7. **Secrets Layer**: Google Cloud Secret Manager

### Network Security

#### VPC Architecture

- **Dedicated VPC**: Separate VPC for Vencura, not default network
- **Private Subnet**: 10.0.0.0/24 for Cloud SQL
- **VPC Connector**: 10.8.0.0/28 for serverless VPC access
- **No Internet Gateway**: No direct internet access from VPC
- **Cloud SQL**: Private IP only, no public IP
- **Firewall Rules**: Default deny, explicit allow only required traffic

#### Zero Trust Implementation

- **Network Zero Trust**: Private IP only, VPC isolation, firewall rules
- **Identity Zero Trust**: Service accounts only, Workload Identity Federation, JWT verification
- **Data Zero Trust**: Encryption at rest and in transit, secret references, key separation
- **Application Zero Trust**: Container isolation, in-memory decryption, request validation

### IAM Security

#### Service Account Management

1. **Cloud Run Service Account**:
   - `roles/secretmanager.secretAccessor` (scoped to specific secrets)
   - `roles/cloudsql.client` (Cloud SQL connection only)
   - Naming: `vencura-{env}-cloud-run-sa`

2. **CI/CD Service Account**:
   - `roles/artifactregistry.writer` (push images)
   - `roles/run.admin` (deploy services)
   - `roles/secretmanager.secretAccessor` (read secrets for deployment)
   - Naming: `vencura-{env}-cicd-sa`

#### Workload Identity Federation

- **Method**: Workload Identity Federation (WIF) for GitHub Actions
- **Benefits**: No long-lived credentials, automatic token rotation, fine-grained access control

### Secret Management

- **Naming Convention**: `vencura-{env}-{secret-name}`
- **Access Control**: IAM-based with conditions
- **Secrets Stored**: `ENCRYPTION_KEY`, `DYNAMIC_ENVIRONMENT_ID`, `DYNAMIC_API_TOKEN`, `DATABASE_URL`, RPC URLs
- **Key Rotation**: Supported via Secret Manager versions

### Database Security

- **Encryption at Rest**: Enabled by default (Google-managed keys)
- **Network Access**: Private IP only, Unix socket via Cloud SQL Proxy
- **SSL/TLS**: Required for all connections
- **Access Control**: Database user with minimal privileges

## Infrastructure as Code

The infrastructure is defined using **Pulumi** with TypeScript:

- Type-safe infrastructure definitions
- Version-controlled infrastructure
- Environment-based deployments (dev/prod)
- Preview changes before applying
- Rollback capabilities

## Deployment Environments

### Development Environment (`vencura-dev`)

- **Deployment**: Automatic on merge to `main` branch
- **Database**: Cloud SQL Postgres (dev instance)
- **Service**: Persistent Cloud Run service
- **Scaling**: 1-1 instances (always running)
- **Custom Domain**: `vencura.{base_domain}` via Cloudflare

### Production Environment (`vencura-prod`)

- **Deployment**: Manual workflow dispatch (requires confirmation)
- **Database**: Cloud SQL Postgres (prod instance with HA)
- **Service**: Persistent Cloud Run service
- **Scaling**: 1-10 instances with auto-scaling
- **Backups**: Enabled (7-day retention)
- **HA**: Enabled (regional)
- **Custom Domain**: `vencura.{base_domain}` via Cloudflare

### Ephemeral PR Deployments (`vencura-pr-{number}`)

- **Deployment**: Automatic on PR creation/update
- **Database**: PGLite (embedded, no Cloud SQL)
- **Service**: Ephemeral Cloud Run service
- **Lifetime**: Auto-deleted on PR close/merge

## CI/CD Integration

### GitHub Actions Workflows

1. **Quality Checks**: Runs on all PRs and pushes (lint, type check, tests)
2. **Dev Deployment**: Automatic on merge to `main` (infrastructure + Docker image)
3. **Prod Deployment**: Manual workflow dispatch (safety measure)

### Authentication

- **Workload Identity Federation**: Secure GCP authentication without service account keys
- **Least Privilege IAM**: Service accounts with minimal required permissions
- **Secret Management**: All secrets stored in Google Cloud Secret Manager

## Setup

For detailed setup instructions, see [Infrastructure README](../../../infra/README.md).

### Quick Start

1. **Prerequisites**: GCP project with billing enabled, Pulumi Cloud account, GitHub repository
2. **Initial Setup**: Install dependencies, login to Pulumi, authenticate with GCP
3. **Configure Infrastructure**: Set up Workload Identity Federation, configure GitHub secrets, create Pulumi stacks
4. **Deploy**: Push to `main` branch for dev deployment, use workflow dispatch for production

## Monitoring and Observability

- **Cloud Logging**: Centralized logging for all services
- **Cloud Monitoring**: Metrics and alerting
- **Error Reporting**: Automatic error tracking
- **Trace**: Distributed tracing support
- **Security Monitoring**: Cloud Monitoring, Security Command Center, audit logs

## Cost Considerations

### Development Environment

- Cloud Run: ~$10-20/month (1 instance always running)
- Cloud SQL: ~$10-15/month (db-f1-micro)
- VPC Connector: ~$5/month
- **Total**: ~$25-40/month

### Production Environment

- Cloud Run: Variable based on traffic
- Cloud SQL: ~$50-100/month (db-g1-small with HA)
- VPC Connector: ~$5/month
- **Total**: Variable, typically $100-200/month for moderate traffic

## Long-Term Vision: Split Architecture

**Important**: We are NOT splitting now. Everything stays on Vercel for the demo/development phase. This split architecture is documented as a potential future option ONLY if production security requirements demand it.

### Potential Split Architecture (For Future Production Security Needs)

**If production security requirements necessitate it, we may consider:**

**UI + Stateless API Glue on Vercel:**

- Next.js frontend applications
- Thin NestJS adapters for user auth, dashboards, webhooks, notifications
- Public API facades

**Key-Custody & Signing Core on Google Cloud:**

- NestJS "signer" service on Cloud Run in private VPC
- Keys in Cloud KMS/HSM (optionally MPC/threshold signing)
- Direct VPC egress control, firewall rules, VPC Flow Logs
- Cloud Armor WAF for public endpoints

**Edge Between the Two:**

- Single public API on GCP protected by mTLS/OAuth SA tokens
- IP allowlisting and Cloud Armor
- Vercel functions call GCP API; everything else stays private

## Migration from Vercel

**Note**: We are currently staying on Vercel. This migration path is documented for potential future use if production security requirements demand it.

When ready to migrate to Google Cloud:

1. Set up infrastructure using Pulumi
2. Configure GitHub Actions workflows
3. Set up secrets in Secret Manager
4. Deploy to dev environment first
5. Test thoroughly
6. Deploy to production
7. Update DNS records to point to Cloud Run

