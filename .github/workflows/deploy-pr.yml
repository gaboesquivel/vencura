name: Deploy PR Preview

on:
  pull_request:
    branches:
      - main
    paths:
      - 'apps/vencura/**'
      - 'infra/**'
      - '.github/workflows/deploy-pr.yml'
    types: [opened, synchronize, reopened, closed]

env:
  PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  REGION: ${{ secrets.GCP_REGION || 'us-central1' }}
  ARTIFACT_REGISTRY: ${{ secrets.GCP_ARTIFACT_REGISTRY || 'vencura' }}
  CLOUDFLARE_BASE_DOMAIN: ${{ secrets.CLOUDFLARE_BASE_DOMAIN || 'gaboesquivel.com' }}

jobs:
  preview-infra:
    name: Preview Infrastructure Changes
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && github.event.action != 'closed'
    permissions:
      contents: read
      id-token: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          fetch-depth: 0

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10.4.1

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          token_format: 'access_token'
          workload_identity_provider: ${{ secrets.WIF_PROVIDER }}
          service_account: ${{ secrets.WIF_SERVICE_ACCOUNT }}
          create_credentials_file: true

      - name: Set Google credentials path
        id: gcp-creds
        run: |
          echo "GOOGLE_GHA_CREDS_PATH=$GOOGLE_APPLICATION_CREDENTIALS" >> $GITHUB_ENV

      - name: Install Pulumi CLI
        uses: pulumi/actions@v6
        with:
          command: version

      - name: Check for infrastructure changes
        id: check-infra
        run: |
          if git diff --name-only origin/main...HEAD | grep -q "^infra/"; then
            echo "has_infra_changes=true" >> $GITHUB_OUTPUT
          else
            echo "has_infra_changes=false" >> $GITHUB_OUTPUT
          fi

      - name: Install infrastructure dependencies
        if: steps.check-infra.outputs.has_infra_changes == 'true'
        working-directory: ./infra/vencura
        run: |
          pnpm install --frozen-lockfile

      - name: Preview infrastructure changes
        if: steps.check-infra.outputs.has_infra_changes == 'true'
        working-directory: ./infra/vencura
        env:
          GOOGLE_CREDENTIALS: ${{ env.GOOGLE_GHA_CREDS_PATH }}
          PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }}
          GCP_PROJECT_ID: ${{ env.PROJECT_ID }}
          GCP_REGION: ${{ env.REGION }}
          GCP_IMAGE_TAG: ${{ github.event.pull_request.head.sha }}
          DYNAMIC_ENVIRONMENT_ID: ${{ secrets.DYNAMIC_ENVIRONMENT_ID }}
          DYNAMIC_API_TOKEN: ${{ secrets.DYNAMIC_API_TOKEN }}
          ARBITRUM_SEPOLIA_RPC_URL: ${{ secrets.ARBITRUM_SEPOLIA_RPC_URL }}
          ENCRYPTION_KEY: ${{ secrets.ENCRYPTION_KEY }}
        run: |
          pulumi stack select dev
          pulumi preview --non-interactive

      - name: Skip preview (no infrastructure changes)
        if: steps.check-infra.outputs.has_infra_changes != 'true'
        run: |
          echo "No infrastructure changes detected, skipping preview"

  deploy-app:
    name: Deploy PR Preview
    runs-on: ubuntu-latest
    if: always() && needs.preview-infra.result != 'failure' && github.event.action != 'closed'
    needs: [preview-infra]
    permissions:
      contents: read
      pull-requests: write
      id-token: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          fetch-depth: 0

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10.4.1

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          token_format: 'access_token'
          workload_identity_provider: ${{ secrets.WIF_PROVIDER }}
          service_account: ${{ secrets.WIF_SERVICE_ACCOUNT }}
          create_credentials_file: true

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Configure Docker for Artifact Registry
        run: |
          gcloud auth configure-docker $REGION-docker.pkg.dev --quiet

      - name: Set Google credentials path
        id: gcp-creds
        run: |
          echo "GOOGLE_GHA_CREDS_PATH=$GOOGLE_APPLICATION_CREDENTIALS" >> $GITHUB_ENV

      - name: Get dev infrastructure outputs
        working-directory: ./infra/vencura
        id: dev-infra
        env:
          PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }}
        run: |
          pulumi stack select dev
          VPC_CONNECTOR=$(pulumi stack output vpcConnectorName)
          SERVICE_ACCOUNT=$(pulumi stack output cloudRunServiceAccountEmail)
          echo "vpc_connector=$VPC_CONNECTOR" >> $GITHUB_OUTPUT
          echo "service_account=$SERVICE_ACCOUNT" >> $GITHUB_OUTPUT

      - name: Sanitize branch name
        id: branch
        run: |
          BRANCH_NAME="${{ github.event.pull_request.head.ref }}"
          # Convert to lowercase
          BRANCH_NAME=$(echo "$BRANCH_NAME" | tr '[:upper:]' '[:lower:]')
          # Replace invalid DNS characters with hyphens
          BRANCH_NAME=$(echo "$BRANCH_NAME" | sed 's/[^a-z0-9-]/-/g')
          # Remove leading/trailing hyphens and multiple consecutive hyphens
          BRANCH_NAME=$(echo "$BRANCH_NAME" | sed 's/^-\+//; s/-\+$//; s/-\+/-/g')
          # Limit to 63 characters (DNS label limit)
          BRANCH_NAME=$(echo "$BRANCH_NAME" | cut -c1-63)
          # Ensure it's not empty
          if [ -z "$BRANCH_NAME" ]; then
            BRANCH_NAME="pr"
          fi
          echo "sanitized=$BRANCH_NAME" >> $GITHUB_OUTPUT
          echo "pr_number=${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
          echo "service_name=vencura-pr-${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT

      - name: Create temporary secrets for PR deployment
        id: create-secrets
        run: |
          PR_NUMBER="${{ github.event.pull_request.number }}"
          SECRET_PREFIX="vencura-pr-$PR_NUMBER"
          
          # Ensure gcloud uses ADC directly (not impersonation)
          gcloud config unset auth/impersonate_service_account 2>/dev/null || true
          gcloud config set auth/impersonate_service_account ""
          
          # Create or update secrets (idempotent)
          echo "${{ secrets.DYNAMIC_ENVIRONMENT_ID }}" | gcloud secrets create ${SECRET_PREFIX}-dynamic-environment-id \
            --data-file=- \
            --replication-policy="automatic" \
            --project=${{ env.PROJECT_ID }} \
            --quiet \
            2>/dev/null || echo "${{ secrets.DYNAMIC_ENVIRONMENT_ID }}" | gcloud secrets versions add ${SECRET_PREFIX}-dynamic-environment-id \
            --data-file=- \
            --project=${{ env.PROJECT_ID }} \
            --quiet
          
          echo "${{ secrets.DYNAMIC_API_TOKEN }}" | gcloud secrets create ${SECRET_PREFIX}-dynamic-api-token \
            --data-file=- \
            --replication-policy="automatic" \
            --project=${{ env.PROJECT_ID }} \
            --quiet \
            2>/dev/null || echo "${{ secrets.DYNAMIC_API_TOKEN }}" | gcloud secrets versions add ${SECRET_PREFIX}-dynamic-api-token \
            --data-file=- \
            --project=${{ env.PROJECT_ID }} \
            --quiet
          
          echo "${{ secrets.ARBITRUM_SEPOLIA_RPC_URL }}" | gcloud secrets create ${SECRET_PREFIX}-arbitrum-sepolia-rpc-url \
            --data-file=- \
            --replication-policy="automatic" \
            --project=${{ env.PROJECT_ID }} \
            --quiet \
            2>/dev/null || echo "${{ secrets.ARBITRUM_SEPOLIA_RPC_URL }}" | gcloud secrets versions add ${SECRET_PREFIX}-arbitrum-sepolia-rpc-url \
            --data-file=- \
            --project=${{ env.PROJECT_ID }} \
            --quiet
          
          echo "${{ secrets.ENCRYPTION_KEY }}" | gcloud secrets create ${SECRET_PREFIX}-encryption-key \
            --data-file=- \
            --replication-policy="automatic" \
            --project=${{ env.PROJECT_ID }} \
            --quiet \
            2>/dev/null || echo "${{ secrets.ENCRYPTION_KEY }}" | gcloud secrets versions add ${SECRET_PREFIX}-encryption-key \
            --data-file=- \
            --project=${{ env.PROJECT_ID }} \
            --quiet
          
          # Grant dev service account access to these secrets
          DEV_SA="${{ steps.dev-infra.outputs.service_account }}"
          
          gcloud secrets add-iam-policy-binding ${SECRET_PREFIX}-dynamic-environment-id \
            --member="serviceAccount:${DEV_SA}" \
            --role="roles/secretmanager.secretAccessor" \
            --project=${{ env.PROJECT_ID }} \
            --quiet || true
          
          gcloud secrets add-iam-policy-binding ${SECRET_PREFIX}-dynamic-api-token \
            --member="serviceAccount:${DEV_SA}" \
            --role="roles/secretmanager.secretAccessor" \
            --project=${{ env.PROJECT_ID }} \
            --quiet || true
          
          gcloud secrets add-iam-policy-binding ${SECRET_PREFIX}-arbitrum-sepolia-rpc-url \
            --member="serviceAccount:${DEV_SA}" \
            --role="roles/secretmanager.secretAccessor" \
            --project=${{ env.PROJECT_ID }} \
            --quiet || true
          
          gcloud secrets add-iam-policy-binding ${SECRET_PREFIX}-encryption-key \
            --member="serviceAccount:${DEV_SA}" \
            --role="roles/secretmanager.secretAccessor" \
            --project=${{ env.PROJECT_ID }} \
            --quiet || true
          
          echo "secret_prefix=$SECRET_PREFIX" >> $GITHUB_OUTPUT

      - name: Build and push Docker image
        run: |
          COMMIT_SHA="${{ github.event.pull_request.head.sha }}"
          IMAGE_TAG="$REGION-docker.pkg.dev/$PROJECT_ID/$ARTIFACT_REGISTRY/vencura:$COMMIT_SHA"
          # Verify build context has required files
          ls -la
          echo "Checking for required files..."
          test -f pnpm-workspace.yaml && echo "âœ“ pnpm-workspace.yaml found" || echo "âœ— pnpm-workspace.yaml missing"
          test -f turbo.json && echo "âœ“ turbo.json found" || echo "âœ— turbo.json missing"
          test -d packages && echo "âœ“ packages directory found" || echo "âœ— packages directory missing"
          test -d apps/vencura && echo "âœ“ apps/vencura directory found" || echo "âœ— apps/vencura directory missing"
          # Build from repository root (build context is .)
          docker build -t $IMAGE_TAG -f apps/vencura/Dockerfile .
          docker push $IMAGE_TAG
          echo "image=$IMAGE_TAG" >> $GITHUB_ENV

      - name: Deploy to Cloud Run
        run: |
          SECRET_PREFIX="${{ steps.create-secrets.outputs.secret_prefix }}"
          SERVICE_ACCOUNT="${{ steps.dev-infra.outputs.service_account }}"
          VPC_CONNECTOR="${{ steps.dev-infra.outputs.vpc_connector }}"
          
          gcloud run deploy ${{ steps.branch.outputs.service_name }} \
            --image ${{ env.image }} \
            --region ${{ env.REGION }} \
            --platform managed \
            --allow-unauthenticated \
            --service-account="$SERVICE_ACCOUNT" \
            --vpc-connector="$VPC_CONNECTOR" \
            --vpc-egress private-ranges-only \
            --port 3077 \
            --memory 512Mi \
            --cpu 1 \
            --min-instances 0 \
            --max-instances 2 \
            --set-env-vars "USE_PGLITE=true" \
            --set-secrets "DYNAMIC_ENVIRONMENT_ID=${SECRET_PREFIX}-dynamic-environment-id:latest,DYNAMIC_API_TOKEN=${SECRET_PREFIX}-dynamic-api-token:latest,ARBITRUM_SEPOLIA_RPC_URL=${SECRET_PREFIX}-arbitrum-sepolia-rpc-url:latest,ENCRYPTION_KEY=${SECRET_PREFIX}-encryption-key:latest" \
            --timeout 300 \
            --quiet

      - name: Get service URL
        id: service-url
        run: |
          URL=$(gcloud run services describe ${{ steps.branch.outputs.service_name }} \
            --region ${{ env.REGION }} \
            --format 'value(status.url)')
          echo "url=$URL" >> $GITHUB_OUTPUT
          
          # Extract hostname from URL (remove https://)
          HOSTNAME=$(echo "$URL" | sed 's|https\?://||' | sed 's|/.*||')
          echo "hostname=$HOSTNAME" >> $GITHUB_OUTPUT

      - name: Create/update Cloudflare DNS record
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
        run: |
          BASE_DOMAIN="${{ env.CLOUDFLARE_BASE_DOMAIN }}"
          SUBDOMAIN="${{ steps.branch.outputs.sanitized }}"
          DOMAIN="${SUBDOMAIN}.vencura.${BASE_DOMAIN}"
          TARGET_HOSTNAME="${{ steps.service-url.outputs.hostname }}"
          
          # Function to check Cloudflare API response
          check_cloudflare_response() {
            local response="$1"
            local operation="$2"
            local success=$(echo "$response" | jq -r '.success // false')
            local errors=$(echo "$response" | jq -r '.errors[]?.message // empty' | head -1)
            
            if [ "$success" != "true" ]; then
              echo "Error: Cloudflare API $operation failed"
              if [ -n "$errors" ]; then
                echo "Error message: $errors"
              fi
              echo "Full response: $response"
              exit 1
            fi
          }
          
          # Check if DNS record exists
          echo "Checking for existing DNS record: ${DOMAIN}"
          GET_RESPONSE=$(curl -s -w "\n%{http_code}" -X GET "https://api.cloudflare.com/client/v4/zones/${CLOUDFLARE_ZONE_ID}/dns_records?type=CNAME&name=${DOMAIN}" \
            -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
            -H "Content-Type: application/json")
          
          HTTP_CODE=$(echo "$GET_RESPONSE" | tail -n1)
          GET_BODY=$(echo "$GET_RESPONSE" | sed '$d')
          
          if [ "$HTTP_CODE" != "200" ]; then
            echo "Error: Failed to query DNS records (HTTP $HTTP_CODE)"
            echo "Response: $GET_BODY"
            exit 1
          fi
          
          check_cloudflare_response "$GET_BODY" "query"
          
          EXISTING_RECORD=$(echo "$GET_BODY" | jq -r '.result[0].id // empty')
          
          if [ -n "$EXISTING_RECORD" ]; then
            # Update existing record
            echo "Updating existing DNS record for ${DOMAIN}"
            UPDATE_RESPONSE=$(curl -s -w "\n%{http_code}" -X PUT "https://api.cloudflare.com/client/v4/zones/${CLOUDFLARE_ZONE_ID}/dns_records/${EXISTING_RECORD}" \
              -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
              -H "Content-Type: application/json" \
              --data "{\"type\":\"CNAME\",\"name\":\"${DOMAIN}\",\"content\":\"${TARGET_HOSTNAME}\",\"ttl\":300,\"proxied\":true}")
            
            HTTP_CODE=$(echo "$UPDATE_RESPONSE" | tail -n1)
            UPDATE_BODY=$(echo "$UPDATE_RESPONSE" | sed '$d')
            
            if [ "$HTTP_CODE" != "200" ]; then
              echo "Error: Failed to update DNS record (HTTP $HTTP_CODE)"
              echo "Response: $UPDATE_BODY"
              exit 1
            fi
            
            check_cloudflare_response "$UPDATE_BODY" "update"
            echo "Successfully updated DNS record for ${DOMAIN}"
          else
            # Create new record
            echo "Creating DNS record for ${DOMAIN}"
            CREATE_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "https://api.cloudflare.com/client/v4/zones/${CLOUDFLARE_ZONE_ID}/dns_records" \
              -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
              -H "Content-Type: application/json" \
              --data "{\"type\":\"CNAME\",\"name\":\"${DOMAIN}\",\"content\":\"${TARGET_HOSTNAME}\",\"ttl\":300,\"proxied\":true}")
            
            HTTP_CODE=$(echo "$CREATE_RESPONSE" | tail -n1)
            CREATE_BODY=$(echo "$CREATE_RESPONSE" | sed '$d')
            
            if [ "$HTTP_CODE" != "200" ]; then
              echo "Error: Failed to create DNS record (HTTP $HTTP_CODE)"
              echo "Response: $CREATE_BODY"
              exit 1
            fi
            
            check_cloudflare_response "$CREATE_BODY" "create"
            echo "Successfully created DNS record for ${DOMAIN}"
          fi
          
          echo "custom_domain=https://${DOMAIN}" >> $GITHUB_ENV

      - name: Comment PR with deployment URL
        uses: actions/github-script@v7
        env:
          CUSTOM_DOMAIN: ${{ env.custom_domain }}
        with:
          script: |
            const url = '${{ steps.service-url.outputs.url }}';
            const customDomain = process.env.CUSTOM_DOMAIN || '';
            const prNumber = ${{ github.event.pull_request.number }};
            const commitSha = '${{ github.event.pull_request.head.sha }}';
            const commitShortSha = commitSha.substring(0, 7);
            
            let body = `ðŸš€ **Ephemeral deployment ready!**
            
            **Cloud Run URL:** ${url}`;
            
            if (customDomain) {
              body += `\n**Custom Domain:** ${customDomain}`;
              body += `\n\n> â±ï¸ **Note:** Custom domain may take a few minutes to propagate. If the custom domain is not accessible yet, use the Cloud Run URL above.`;
            }
            
            body += `\n\n**Commit:** \`${commitShortSha}\`
            
            This deployment uses PGLite (embedded database) and will be automatically cleaned up when the PR is closed or merged.`;

            // Find existing comment from this workflow
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
            });

            const botComment = comments.data.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('ðŸš€ **Ephemeral deployment ready!**')
            );

            if (botComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
            } else {
              // Create new comment if none exists
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: body
              });
            }

  cleanup:
    name: Cleanup PR Deployment
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && github.event.action == 'closed'
    permissions:
      contents: read
      id-token: write

    steps:
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          token_format: 'access_token'
          workload_identity_provider: ${{ secrets.WIF_PROVIDER }}
          service_account: ${{ secrets.WIF_SERVICE_ACCOUNT }}
          create_credentials_file: true

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Cleanup ephemeral deployment
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
          REGION: ${{ env.REGION }}
          PROJECT_ID: ${{ env.PROJECT_ID }}
          CLOUDFLARE_BASE_DOMAIN: ${{ env.CLOUDFLARE_BASE_DOMAIN }}
        run: |
          PR_NUMBER=${{ github.event.pull_request.number }}
          SERVICE_NAME="vencura-pr-$PR_NUMBER"
          SECRET_PREFIX="vencura-pr-$PR_NUMBER"
          
          # Function to sanitize branch name for DNS
          sanitize_branch_name() {
            local branch="$1"
            branch=$(echo "$branch" | tr '[:upper:]' '[:lower:]')
            branch=$(echo "$branch" | sed 's/[^a-z0-9-]/-/g')
            branch=$(echo "$branch" | sed 's/^-\+//; s/-\+$//; s/-\+/-/g')
            branch=$(echo "$branch" | cut -c1-63)
            if [ -z "$branch" ]; then
              branch="pr"
            fi
            echo "$branch"
          }
          
          # Extract and sanitize branch name
          BASE_DOMAIN="${{ env.CLOUDFLARE_BASE_DOMAIN }}"
          BRANCH_NAME="${{ github.event.pull_request.head.ref }}"
          SANITIZED_BRANCH=$(sanitize_branch_name "$BRANCH_NAME")
          DOMAIN="${SANITIZED_BRANCH}.vencura.${BASE_DOMAIN}"
          
          # Function to check Cloudflare API response
          check_cloudflare_response() {
            local response="$1"
            local operation="$2"
            local success=$(echo "$response" | jq -r '.success // false')
            local errors=$(echo "$response" | jq -r '.errors[]?.message // empty' | head -1)
            
            if [ "$success" != "true" ]; then
              echo "Warning: Cloudflare API $operation failed (continuing cleanup)"
              if [ -n "$errors" ]; then
                echo "Error message: $errors"
              fi
              echo "Full response: $response"
              return 1
            fi
            return 0
          }
          
          # Delete Cloudflare DNS record
          echo "Deleting Cloudflare DNS record for ${DOMAIN}..."
          GET_RESPONSE=$(curl -s -w "\n%{http_code}" -X GET "https://api.cloudflare.com/client/v4/zones/${CLOUDFLARE_ZONE_ID}/dns_records?type=CNAME&name=${DOMAIN}" \
            -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
            -H "Content-Type: application/json")
          
          HTTP_CODE=$(echo "$GET_RESPONSE" | tail -n1)
          GET_BODY=$(echo "$GET_RESPONSE" | sed '$d')
          
          if [ "$HTTP_CODE" = "200" ]; then
            check_cloudflare_response "$GET_BODY" "query" || true
            DNS_RECORD_ID=$(echo "$GET_BODY" | jq -r '.result[0].id // empty')
            
            if [ -n "$DNS_RECORD_ID" ]; then
              DELETE_RESPONSE=$(curl -s -w "\n%{http_code}" -X DELETE "https://api.cloudflare.com/client/v4/zones/${CLOUDFLARE_ZONE_ID}/dns_records/${DNS_RECORD_ID}" \
                -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
                -H "Content-Type: application/json")
              
              HTTP_CODE=$(echo "$DELETE_RESPONSE" | tail -n1)
              DELETE_BODY=$(echo "$DELETE_RESPONSE" | sed '$d')
              
              if [ "$HTTP_CODE" = "200" ]; then
                check_cloudflare_response "$DELETE_BODY" "delete" && echo "Deleted DNS record for ${DOMAIN}" || echo "Warning: DNS record deletion may have failed"
              else
                echo "Warning: Failed to delete DNS record (HTTP $HTTP_CODE)"
                echo "Response: $DELETE_BODY"
              fi
            else
              echo "DNS record for ${DOMAIN} not found or already deleted"
            fi
          else
            echo "Warning: Failed to query DNS records for deletion (HTTP $HTTP_CODE)"
            echo "Response: $GET_BODY"
          fi
          
          # Delete Cloud Run service
          gcloud run services delete $SERVICE_NAME \
            --region ${{ env.REGION }} \
            --quiet || echo "Failed to delete service $SERVICE_NAME"
          
          # Delete temporary secrets
          echo "Cleaning up temporary secrets for PR $PR_NUMBER..."
          
          for SECRET_NAME in "${SECRET_PREFIX}-dynamic-environment-id" "${SECRET_PREFIX}-dynamic-api-token" "${SECRET_PREFIX}-arbitrum-sepolia-rpc-url" "${SECRET_PREFIX}-encryption-key"; do
            gcloud secrets delete $SECRET_NAME \
              --project=${{ env.PROJECT_ID }} \
              --quiet || echo "Secret $SECRET_NAME not found or already deleted"
          done
          
          echo "Cleanup completed for PR $PR_NUMBER"

