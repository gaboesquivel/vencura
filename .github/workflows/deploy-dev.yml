name: Deploy to Dev

on:
  workflow_run:
    workflows: ["Quality Checks"]
    types:
      - completed
  pull_request:
    branches:
      - main
    paths:
      - 'apps/vencura/**'
      - '.github/workflows/deploy-dev.yml'
  push:
    branches:
      - main
    paths:
      - 'apps/vencura/**'
      - '.github/workflows/deploy-dev.yml'

env:
  PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  REGION: ${{ secrets.GCP_REGION || 'us-central1' }}
  SERVICE_NAME_DEV: vencura-dev
  ARTIFACT_REGISTRY: ${{ secrets.GCP_ARTIFACT_REGISTRY || 'vencura' }}
  CLOUDFLARE_BASE_DOMAIN: ${{ secrets.CLOUDFLARE_BASE_DOMAIN || 'gaboesquivel.com' }}

jobs:
  deploy:
    name: Deploy to Dev Environment
    runs-on: ubuntu-latest
    if: (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success') || (github.event_name != 'workflow_run')
    permissions:
      contents: read
      pull-requests: write
      id-token: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha || github.sha }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10.4.1

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.WIF_PROVIDER }}
          service_account: ${{ secrets.WIF_SERVICE_ACCOUNT }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Configure Docker for Artifact Registry
        run: |
          gcloud auth configure-docker $REGION-docker.pkg.dev

      - name: Install Pulumi
        uses: pulumi/actions@v4

      - name: Determine deployment type
        id: deployment
        run: |
          # Function to sanitize branch name for DNS
          sanitize_branch_name() {
            local branch="$1"
            # Convert to lowercase
            branch=$(echo "$branch" | tr '[:upper:]' '[:lower:]')
            # Replace invalid DNS characters with hyphens
            branch=$(echo "$branch" | sed 's/[^a-z0-9-]/-/g')
            # Remove leading/trailing hyphens and multiple consecutive hyphens
            branch=$(echo "$branch" | sed 's/^-\+//; s/-\+$//; s/-\+/-/g')
            # Limit to 63 characters (DNS label limit)
            branch=$(echo "$branch" | cut -c1-63)
            # Ensure it's not empty
            if [ -z "$branch" ]; then
              branch="pr"
            fi
            echo "$branch"
          }
          
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            PR_NUMBER=${{ github.event.pull_request.number }}
            BRANCH_NAME="${{ github.event.pull_request.head.ref }}"
            SANITIZED_BRANCH=$(sanitize_branch_name "$BRANCH_NAME")
            echo "type=ephemeral" >> $GITHUB_OUTPUT
            echo "service_name=vencura-pr-$PR_NUMBER" >> $GITHUB_OUTPUT
            echo "use_pglite=true" >> $GITHUB_OUTPUT
            echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
            echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
            echo "sanitized_branch=$SANITIZED_BRANCH" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" == "push" ]; then
            # Direct push event (to main branch)
            echo "type=persistent" >> $GITHUB_OUTPUT
            echo "service_name=$SERVICE_NAME_DEV" >> $GITHUB_OUTPUT
            echo "use_pglite=false" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" == "workflow_run" ]; then
            # For workflow_run, check if it was triggered by a PR
            PR_NUMBER="${{ github.event.workflow_run.pull_requests[0].number }}"
            HEAD_BRANCH="${{ github.event.workflow_run.head_branch }}"
            if [ -n "$PR_NUMBER" ] && [ "$PR_NUMBER" != "null" ] && [ "$PR_NUMBER" != "" ]; then
              # Workflow was triggered by a PR
              SANITIZED_BRANCH=$(sanitize_branch_name "$HEAD_BRANCH")
              echo "type=ephemeral" >> $GITHUB_OUTPUT
              echo "service_name=vencura-pr-$PR_NUMBER" >> $GITHUB_OUTPUT
              echo "use_pglite=true" >> $GITHUB_OUTPUT
              echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
              echo "branch_name=$HEAD_BRANCH" >> $GITHUB_OUTPUT
              echo "sanitized_branch=$SANITIZED_BRANCH" >> $GITHUB_OUTPUT
            elif [ "$HEAD_BRANCH" == "main" ]; then
              # Workflow was triggered by push to main
              echo "type=persistent" >> $GITHUB_OUTPUT
              echo "service_name=$SERVICE_NAME_DEV" >> $GITHUB_OUTPUT
              echo "use_pglite=false" >> $GITHUB_OUTPUT
            else
              # Unknown branch, default to persistent
              echo "type=persistent" >> $GITHUB_OUTPUT
              echo "service_name=$SERVICE_NAME_DEV" >> $GITHUB_OUTPUT
              echo "use_pglite=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "type=persistent" >> $GITHUB_OUTPUT
            echo "service_name=$SERVICE_NAME_DEV" >> $GITHUB_OUTPUT
            echo "use_pglite=false" >> $GITHUB_OUTPUT
          fi

      - name: Build Docker image
        run: |
          COMMIT_SHA="${{ github.event.workflow_run.head_sha || github.sha }}"
          IMAGE_TAG="$REGION-docker.pkg.dev/$PROJECT_ID/$ARTIFACT_REGISTRY/vencura:$COMMIT_SHA"
          docker build -t $IMAGE_TAG -f apps/vencura/Dockerfile .
          docker push $IMAGE_TAG
          echo "image=$IMAGE_TAG" >> $GITHUB_ENV

      - name: Create temporary secrets for PR deployment
        if: steps.deployment.outputs.type == 'ephemeral'
        id: create-secrets
        run: |
          PR_NUMBER="${{ steps.deployment.outputs.pr_number }}"
          SECRET_PREFIX="vencura-pr-$PR_NUMBER"
          
          # Create temporary secrets in Secret Manager
          # Note: CI/CD service account needs roles/secretmanager.admin or roles/secretmanager.secretAccessor + roles/secretmanager.secretVersionAdder
          
          # Create or update secrets (idempotent)
          echo "${{ secrets.DYNAMIC_ENVIRONMENT_ID }}" | gcloud secrets create ${SECRET_PREFIX}-dynamic-environment-id \
            --data-file=- \
            --replication-policy="automatic" \
            --project=${{ env.PROJECT_ID }} \
            2>/dev/null || echo "${{ secrets.DYNAMIC_ENVIRONMENT_ID }}" | gcloud secrets versions add ${SECRET_PREFIX}-dynamic-environment-id \
            --data-file=- \
            --project=${{ env.PROJECT_ID }}
          
          echo "${{ secrets.DYNAMIC_API_TOKEN }}" | gcloud secrets create ${SECRET_PREFIX}-dynamic-api-token \
            --data-file=- \
            --replication-policy="automatic" \
            --project=${{ env.PROJECT_ID }} \
            2>/dev/null || echo "${{ secrets.DYNAMIC_API_TOKEN }}" | gcloud secrets versions add ${SECRET_PREFIX}-dynamic-api-token \
            --data-file=- \
            --project=${{ env.PROJECT_ID }}
          
          echo "${{ secrets.ARBITRUM_SEPOLIA_RPC_URL }}" | gcloud secrets create ${SECRET_PREFIX}-arbitrum-sepolia-rpc-url \
            --data-file=- \
            --replication-policy="automatic" \
            --project=${{ env.PROJECT_ID }} \
            2>/dev/null || echo "${{ secrets.ARBITRUM_SEPOLIA_RPC_URL }}" | gcloud secrets versions add ${SECRET_PREFIX}-arbitrum-sepolia-rpc-url \
            --data-file=- \
            --project=${{ env.PROJECT_ID }}
          
          echo "${{ secrets.ENCRYPTION_KEY }}" | gcloud secrets create ${SECRET_PREFIX}-encryption-key \
            --data-file=- \
            --replication-policy="automatic" \
            --project=${{ env.PROJECT_ID }} \
            2>/dev/null || echo "${{ secrets.ENCRYPTION_KEY }}" | gcloud secrets versions add ${SECRET_PREFIX}-encryption-key \
            --data-file=- \
            --project=${{ env.PROJECT_ID }}
          
          # Grant Cloud Run default compute service account access to these secrets
          # For ephemeral deployments, Cloud Run uses the default compute service account
          # Format: {PROJECT_NUMBER}-compute@developer.gserviceaccount.com
          PROJECT_NUMBER=$(gcloud projects describe ${{ env.PROJECT_ID }} --format="value(projectNumber)")
          DEFAULT_SA="${PROJECT_NUMBER}-compute@developer.gserviceaccount.com"
          
          # Grant access to temporary secrets
          gcloud secrets add-iam-policy-binding ${SECRET_PREFIX}-dynamic-environment-id \
            --member="serviceAccount:${DEFAULT_SA}" \
            --role="roles/secretmanager.secretAccessor" \
            --project=${{ env.PROJECT_ID }} || true
          
          gcloud secrets add-iam-policy-binding ${SECRET_PREFIX}-dynamic-api-token \
            --member="serviceAccount:${DEFAULT_SA}" \
            --role="roles/secretmanager.secretAccessor" \
            --project=${{ env.PROJECT_ID }} || true
          
          gcloud secrets add-iam-policy-binding ${SECRET_PREFIX}-arbitrum-sepolia-rpc-url \
            --member="serviceAccount:${DEFAULT_SA}" \
            --role="roles/secretmanager.secretAccessor" \
            --project=${{ env.PROJECT_ID }} || true
          
          gcloud secrets add-iam-policy-binding ${SECRET_PREFIX}-encryption-key \
            --member="serviceAccount:${DEFAULT_SA}" \
            --role="roles/secretmanager.secretAccessor" \
            --project=${{ env.PROJECT_ID }} || true
          
          echo "service_account=$DEFAULT_SA" >> $GITHUB_OUTPUT
          
          echo "secret_prefix=$SECRET_PREFIX" >> $GITHUB_OUTPUT

      - name: Deploy to Cloud Run (Ephemeral PR)
        if: steps.deployment.outputs.type == 'ephemeral'
        run: |
          SECRET_PREFIX="${{ steps.create-secrets.outputs.secret_prefix }}"
          SERVICE_ACCOUNT="${{ steps.create-secrets.outputs.service_account }}"
          
          gcloud run deploy ${{ steps.deployment.outputs.service_name }} \
            --image ${{ env.image }} \
            --region ${{ env.REGION }} \
            --platform managed \
            --allow-unauthenticated \
            --service-account="$SERVICE_ACCOUNT" \
            --port 3077 \
            --memory 512Mi \
            --cpu 1 \
            --min-instances 0 \
            --max-instances 2 \
            --set-env-vars "USE_PGLITE=true" \
            --set-secrets "DYNAMIC_ENVIRONMENT_ID=${SECRET_PREFIX}-dynamic-environment-id:latest,DYNAMIC_API_TOKEN=${SECRET_PREFIX}-dynamic-api-token:latest,ARBITRUM_SEPOLIA_RPC_URL=${SECRET_PREFIX}-arbitrum-sepolia-rpc-url:latest,ENCRYPTION_KEY=${SECRET_PREFIX}-encryption-key:latest" \
            --timeout 300 \
            --quiet

      - name: Install infrastructure dependencies
        if: steps.deployment.outputs.type == 'persistent'
        working-directory: ./infra/vencura
        run: |
          pnpm install --frozen-lockfile

      - name: Set Pulumi config from environment variables
        if: steps.deployment.outputs.type == 'persistent'
        working-directory: ./infra/vencura
        env:
          PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }}
        run: |
          pulumi stack select dev
          pulumi config set gcp:project ${{ env.PROJECT_ID }} --non-interactive
          pulumi config set gcp:region ${{ env.REGION }} --non-interactive

      - name: Preview infrastructure changes
        if: steps.deployment.outputs.type == 'persistent'
        working-directory: ./infra/vencura
        env:
          PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }}
          GCP_PROJECT_ID: ${{ env.PROJECT_ID }}
          GCP_REGION: ${{ env.REGION }}
        run: |
          pulumi stack select dev
          pulumi preview --non-interactive

      - name: Update infrastructure
        if: steps.deployment.outputs.type == 'persistent'
        working-directory: ./infra/vencura
        env:
          PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }}
          GCP_PROJECT_ID: ${{ env.PROJECT_ID }}
          GCP_REGION: ${{ env.REGION }}
        run: |
          pulumi stack select dev
          pulumi up --yes --non-interactive

      - name: Get infrastructure outputs
        if: steps.deployment.outputs.type == 'persistent'
        working-directory: ./infra/vencura
        id: pulumi-outputs
        env:
          PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }}
          GCP_PROJECT_ID: ${{ env.PROJECT_ID }}
          GCP_REGION: ${{ env.REGION }}
        run: |
          pulumi stack select dev
          CLOUD_RUN_URL=$(pulumi stack output cloudRunUrl)
          DB_CONNECTION=$(pulumi stack output databaseConnectionName)
          VPC_CONNECTOR=$(pulumi stack output vpcConnectorName)
          SERVICE_ACCOUNT=$(pulumi stack output cloudRunServiceAccountEmail)
          
          echo "cloud_run_url=$CLOUD_RUN_URL" >> $GITHUB_OUTPUT
          echo "db_connection=$DB_CONNECTION" >> $GITHUB_OUTPUT
          echo "vpc_connector=$VPC_CONNECTOR" >> $GITHUB_OUTPUT
          echo "service_account=$SERVICE_ACCOUNT" >> $GITHUB_OUTPUT

      - name: Update Cloud Run service with new image
        if: steps.deployment.outputs.type == 'persistent'
        run: |
          gcloud run services update ${{ steps.deployment.outputs.service_name }} \
            --image ${{ env.image }} \
            --region ${{ env.REGION }} \
            --quiet

      - name: Get service URL
        id: service-url
        run: |
          if [ "${{ steps.deployment.outputs.type }}" == "persistent" ]; then
            URL="${{ steps.pulumi-outputs.outputs.cloud_run_url }}"
          else
            URL=$(gcloud run services describe ${{ steps.deployment.outputs.service_name }} \
              --region ${{ env.REGION }} \
              --format 'value(status.url)')
          fi
          echo "url=$URL" >> $GITHUB_OUTPUT
          
          # Extract hostname from URL (remove https://)
          HOSTNAME=$(echo "$URL" | sed 's|https\?://||' | sed 's|/.*||')
          echo "hostname=$HOSTNAME" >> $GITHUB_OUTPUT

      - name: Create/update Cloudflare DNS record (Ephemeral PR)
        if: steps.deployment.outputs.type == 'ephemeral'
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
        run: |
          BASE_DOMAIN="${{ env.CLOUDFLARE_BASE_DOMAIN }}"
          SUBDOMAIN="${{ steps.deployment.outputs.sanitized_branch }}"
          DOMAIN="${SUBDOMAIN}.vencura.${BASE_DOMAIN}"
          TARGET_HOSTNAME="${{ steps.service-url.outputs.hostname }}"
          
          # Function to check Cloudflare API response
          check_cloudflare_response() {
            local response="$1"
            local operation="$2"
            local success=$(echo "$response" | jq -r '.success // false')
            local errors=$(echo "$response" | jq -r '.errors[]?.message // empty' | head -1)
            
            if [ "$success" != "true" ]; then
              echo "Error: Cloudflare API $operation failed"
              if [ -n "$errors" ]; then
                echo "Error message: $errors"
              fi
              echo "Full response: $response"
              exit 1
            fi
          }
          
          # Check if DNS record exists
          echo "Checking for existing DNS record: ${DOMAIN}"
          GET_RESPONSE=$(curl -s -w "\n%{http_code}" -X GET "https://api.cloudflare.com/client/v4/zones/${CLOUDFLARE_ZONE_ID}/dns_records?type=CNAME&name=${DOMAIN}" \
            -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
            -H "Content-Type: application/json")
          
          HTTP_CODE=$(echo "$GET_RESPONSE" | tail -n1)
          GET_BODY=$(echo "$GET_RESPONSE" | sed '$d')
          
          if [ "$HTTP_CODE" != "200" ]; then
            echo "Error: Failed to query DNS records (HTTP $HTTP_CODE)"
            echo "Response: $GET_BODY"
            exit 1
          fi
          
          check_cloudflare_response "$GET_BODY" "query"
          
          EXISTING_RECORD=$(echo "$GET_BODY" | jq -r '.result[0].id // empty')
          
          if [ -n "$EXISTING_RECORD" ]; then
            # Update existing record
            echo "Updating existing DNS record for ${DOMAIN}"
            UPDATE_RESPONSE=$(curl -s -w "\n%{http_code}" -X PUT "https://api.cloudflare.com/client/v4/zones/${CLOUDFLARE_ZONE_ID}/dns_records/${EXISTING_RECORD}" \
              -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
              -H "Content-Type: application/json" \
              --data "{\"type\":\"CNAME\",\"name\":\"${DOMAIN}\",\"content\":\"${TARGET_HOSTNAME}\",\"ttl\":300,\"proxied\":true}")
            
            HTTP_CODE=$(echo "$UPDATE_RESPONSE" | tail -n1)
            UPDATE_BODY=$(echo "$UPDATE_RESPONSE" | sed '$d')
            
            if [ "$HTTP_CODE" != "200" ]; then
              echo "Error: Failed to update DNS record (HTTP $HTTP_CODE)"
              echo "Response: $UPDATE_BODY"
              exit 1
            fi
            
            check_cloudflare_response "$UPDATE_BODY" "update"
            echo "Successfully updated DNS record for ${DOMAIN}"
          else
            # Create new record
            echo "Creating DNS record for ${DOMAIN}"
            CREATE_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "https://api.cloudflare.com/client/v4/zones/${CLOUDFLARE_ZONE_ID}/dns_records" \
              -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
              -H "Content-Type: application/json" \
              --data "{\"type\":\"CNAME\",\"name\":\"${DOMAIN}\",\"content\":\"${TARGET_HOSTNAME}\",\"ttl\":300,\"proxied\":true}")
            
            HTTP_CODE=$(echo "$CREATE_RESPONSE" | tail -n1)
            CREATE_BODY=$(echo "$CREATE_RESPONSE" | sed '$d')
            
            if [ "$HTTP_CODE" != "200" ]; then
              echo "Error: Failed to create DNS record (HTTP $HTTP_CODE)"
              echo "Response: $CREATE_BODY"
              exit 1
            fi
            
            check_cloudflare_response "$CREATE_BODY" "create"
            echo "Successfully created DNS record for ${DOMAIN}"
          fi
          
          echo "custom_domain=https://${DOMAIN}" >> $GITHUB_ENV

      - name: Create/update Cloudflare DNS record (Dev)
        if: steps.deployment.outputs.type == 'persistent'
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
        run: |
          BASE_DOMAIN="${{ env.CLOUDFLARE_BASE_DOMAIN }}"
          DOMAIN="vencura.${BASE_DOMAIN}"
          TARGET_HOSTNAME="${{ steps.service-url.outputs.hostname }}"
          
          # Function to check Cloudflare API response
          check_cloudflare_response() {
            local response="$1"
            local operation="$2"
            local success=$(echo "$response" | jq -r '.success // false')
            local errors=$(echo "$response" | jq -r '.errors[]?.message // empty' | head -1)
            
            if [ "$success" != "true" ]; then
              echo "Error: Cloudflare API $operation failed"
              if [ -n "$errors" ]; then
                echo "Error message: $errors"
              fi
              echo "Full response: $response"
              exit 1
            fi
          }
          
          # Check if DNS record exists
          echo "Checking for existing DNS record: ${DOMAIN}"
          GET_RESPONSE=$(curl -s -w "\n%{http_code}" -X GET "https://api.cloudflare.com/client/v4/zones/${CLOUDFLARE_ZONE_ID}/dns_records?type=CNAME&name=${DOMAIN}" \
            -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
            -H "Content-Type: application/json")
          
          HTTP_CODE=$(echo "$GET_RESPONSE" | tail -n1)
          GET_BODY=$(echo "$GET_RESPONSE" | sed '$d')
          
          if [ "$HTTP_CODE" != "200" ]; then
            echo "Error: Failed to query DNS records (HTTP $HTTP_CODE)"
            echo "Response: $GET_BODY"
            exit 1
          fi
          
          check_cloudflare_response "$GET_BODY" "query"
          
          EXISTING_RECORD=$(echo "$GET_BODY" | jq -r '.result[0].id // empty')
          
          if [ -n "$EXISTING_RECORD" ]; then
            # Update existing record
            echo "Updating existing DNS record for ${DOMAIN}"
            UPDATE_RESPONSE=$(curl -s -w "\n%{http_code}" -X PUT "https://api.cloudflare.com/client/v4/zones/${CLOUDFLARE_ZONE_ID}/dns_records/${EXISTING_RECORD}" \
              -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
              -H "Content-Type: application/json" \
              --data "{\"type\":\"CNAME\",\"name\":\"${DOMAIN}\",\"content\":\"${TARGET_HOSTNAME}\",\"ttl\":300,\"proxied\":true}")
            
            HTTP_CODE=$(echo "$UPDATE_RESPONSE" | tail -n1)
            UPDATE_BODY=$(echo "$UPDATE_RESPONSE" | sed '$d')
            
            if [ "$HTTP_CODE" != "200" ]; then
              echo "Error: Failed to update DNS record (HTTP $HTTP_CODE)"
              echo "Response: $UPDATE_BODY"
              exit 1
            fi
            
            check_cloudflare_response "$UPDATE_BODY" "update"
            echo "Successfully updated DNS record for ${DOMAIN}"
          else
            # Create new record
            echo "Creating DNS record for ${DOMAIN}"
            CREATE_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "https://api.cloudflare.com/client/v4/zones/${CLOUDFLARE_ZONE_ID}/dns_records" \
              -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
              -H "Content-Type: application/json" \
              --data "{\"type\":\"CNAME\",\"name\":\"${DOMAIN}\",\"content\":\"${TARGET_HOSTNAME}\",\"ttl\":300,\"proxied\":true}")
            
            HTTP_CODE=$(echo "$CREATE_RESPONSE" | tail -n1)
            CREATE_BODY=$(echo "$CREATE_RESPONSE" | sed '$d')
            
            if [ "$HTTP_CODE" != "200" ]; then
              echo "Error: Failed to create DNS record (HTTP $HTTP_CODE)"
              echo "Response: $CREATE_BODY"
              exit 1
            fi
            
            check_cloudflare_response "$CREATE_BODY" "update"
            echo "Successfully created DNS record for ${DOMAIN}"
          fi
          
          echo "custom_domain=https://${DOMAIN}" >> $GITHUB_ENV

      - name: Comment PR with deployment URL
        if: steps.deployment.outputs.type == 'ephemeral' && steps.deployment.outputs.pr_number != ''
        uses: actions/github-script@v7
        env:
          CUSTOM_DOMAIN: ${{ env.custom_domain }}
        with:
          script: |
            const url = '${{ steps.service-url.outputs.url }}';
            const customDomain = process.env.CUSTOM_DOMAIN || '';
            const prNumber = '${{ steps.deployment.outputs.pr_number }}';
            const commitSha = '${{ github.event.workflow_run.head_sha || github.sha }}';
            const commitShortSha = commitSha.substring(0, 7);
            
            let body = `ðŸš€ **Ephemeral deployment ready!**
            
            **Cloud Run URL:** ${url}`;
            
            if (customDomain) {
              body += `\n**Custom Domain:** ${customDomain}`;
              body += `\n\n> â±ï¸ **Note:** Custom domain may take a few minutes to propagate. If the custom domain is not accessible yet, use the Cloud Run URL above.`;
            }
            
            body += `\n\n**Commit:** \`${commitShortSha}\`
            
            This deployment uses PGLite (embedded database) and will be automatically cleaned up when the PR is closed or merged.`;

            // Find existing comment from this workflow
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: parseInt(prNumber),
            });

            const botComment = comments.data.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('ðŸš€ **Ephemeral deployment ready!**')
            );

            if (botComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
            } else {
              // Create new comment if none exists
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: parseInt(prNumber),
                body: body
              });
            }

      - name: Cleanup ephemeral deployment on PR close
        if: github.event_name == 'pull_request' && github.event.action == 'closed'
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
        run: |
          PR_NUMBER=${{ github.event.pull_request.number }}
          SERVICE_NAME="vencura-pr-$PR_NUMBER"
          SECRET_PREFIX="vencura-pr-$PR_NUMBER"
          
          # Function to sanitize branch name for DNS (same as deployment step)
          sanitize_branch_name() {
            local branch="$1"
            branch=$(echo "$branch" | tr '[:upper:]' '[:lower:]')
            branch=$(echo "$branch" | sed 's/[^a-z0-9-]/-/g')
            branch=$(echo "$branch" | sed 's/^-\+//; s/-\+$//; s/-\+/-/g')
            branch=$(echo "$branch" | cut -c1-63)
            if [ -z "$branch" ]; then
              branch="pr"
            fi
            echo "$branch"
          }
          
          # Extract and sanitize branch name
          BASE_DOMAIN="${{ env.CLOUDFLARE_BASE_DOMAIN }}"
          BRANCH_NAME="${{ github.event.pull_request.head.ref }}"
          SANITIZED_BRANCH=$(sanitize_branch_name "$BRANCH_NAME")
          DOMAIN="${SANITIZED_BRANCH}.vencura.${BASE_DOMAIN}"
          
          # Function to check Cloudflare API response
          check_cloudflare_response() {
            local response="$1"
            local operation="$2"
            local success=$(echo "$response" | jq -r '.success // false')
            local errors=$(echo "$response" | jq -r '.errors[]?.message // empty' | head -1)
            
            if [ "$success" != "true" ]; then
              echo "Warning: Cloudflare API $operation failed (continuing cleanup)"
              if [ -n "$errors" ]; then
                echo "Error message: $errors"
              fi
              echo "Full response: $response"
              # Don't exit on cleanup errors - continue with other cleanup tasks
              return 1
            fi
            return 0
          }
          
          # Delete Cloudflare DNS record
          echo "Deleting Cloudflare DNS record for ${DOMAIN}..."
          GET_RESPONSE=$(curl -s -w "\n%{http_code}" -X GET "https://api.cloudflare.com/client/v4/zones/${CLOUDFLARE_ZONE_ID}/dns_records?type=CNAME&name=${DOMAIN}" \
            -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
            -H "Content-Type: application/json")
          
          HTTP_CODE=$(echo "$GET_RESPONSE" | tail -n1)
          GET_BODY=$(echo "$GET_RESPONSE" | sed '$d')
          
          if [ "$HTTP_CODE" = "200" ]; then
            check_cloudflare_response "$GET_BODY" "query" || true
            DNS_RECORD_ID=$(echo "$GET_BODY" | jq -r '.result[0].id // empty')
            
            if [ -n "$DNS_RECORD_ID" ]; then
              DELETE_RESPONSE=$(curl -s -w "\n%{http_code}" -X DELETE "https://api.cloudflare.com/client/v4/zones/${CLOUDFLARE_ZONE_ID}/dns_records/${DNS_RECORD_ID}" \
                -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
                -H "Content-Type: application/json")
              
              HTTP_CODE=$(echo "$DELETE_RESPONSE" | tail -n1)
              DELETE_BODY=$(echo "$DELETE_RESPONSE" | sed '$d')
              
              if [ "$HTTP_CODE" = "200" ]; then
                check_cloudflare_response "$DELETE_BODY" "delete" && echo "Deleted DNS record for ${DOMAIN}" || echo "Warning: DNS record deletion may have failed"
              else
                echo "Warning: Failed to delete DNS record (HTTP $HTTP_CODE)"
                echo "Response: $DELETE_BODY"
              fi
            else
              echo "DNS record for ${DOMAIN} not found or already deleted"
            fi
          else
            echo "Warning: Failed to query DNS records for deletion (HTTP $HTTP_CODE)"
            echo "Response: $GET_BODY"
          fi
          
          # Delete Cloud Run service
          gcloud run services delete $SERVICE_NAME \
            --region ${{ env.REGION }} \
            --quiet || echo "Failed to delete service $SERVICE_NAME"
          
          # Delete temporary secrets
          echo "Cleaning up temporary secrets for PR $PR_NUMBER..."
          
          for SECRET_NAME in "${SECRET_PREFIX}-dynamic-environment-id" "${SECRET_PREFIX}-dynamic-api-token" "${SECRET_PREFIX}-arbitrum-sepolia-rpc-url" "${SECRET_PREFIX}-encryption-key"; do
            gcloud secrets delete $SECRET_NAME \
              --project=${{ env.PROJECT_ID }} \
              --quiet || echo "Secret $SECRET_NAME not found or already deleted"
          done
          
          echo "Cleanup completed for PR $PR_NUMBER"
