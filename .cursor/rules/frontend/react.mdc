---
description: React component patterns and best practices
globs: *.tsx,*.ts
alwaysApply: false
---
# React Rules

## Component Structure
- Separate UI and business logic into different components

## Props and State
- Follow the RORO (Receive an Object, Return an Object) pattern for props
- **Use `useSetState` from `react-use` when multiple related state variables are updated together**
- Group related state into a single state object instead of multiple `useState` calls

## Rendering Optimization
- Memoize expensive calculations with useMemo
- Use memo for pure components that render often
- Use useCallback for functions passed to child components
- Avoid creating new objects/arrays in render

## State Management

### State Management Decision Tree

Choose the right state management approach based on your use case:

1. **URL-shareable UI state** → Use `nuqs` (filters, search, tabs, pagination, view preferences)
2. **Grouped state not in URL** → Use `useSetState` (game engine, form state, ephemeral UI state)
3. **Loading/error states from async operations** → Use TanStack Query's built-in state (`isLoading`, `isError`, `isFetching`)
4. **Simple independent state** → Use `useState` (rare, prefer other options)

### URL State Management with nuqs

Use `nuqs` for UI state that should be shareable via URL. This makes state bookmarkable, shareable, and persists across page refreshes.

❌ **Don't**: Use `useState` or `useSetState` for URL-shareable state
```tsx
// Bad - state not in URL, not shareable
const [search, setSearch] = useState('')
const [page, setPage] = useState(1)
const [activeTab, setActiveTab] = useState('overview')
```

✅ **Do**: Use `nuqs` for URL-shareable state
```tsx
// Good - state in URL, shareable and bookmarkable
import { useQueryState, useQueryStates, parseAsString, parseAsInteger, parseAsStringEnum } from 'nuqs'

const tabs = ['overview', 'settings', 'analytics'] as const

export function useFilters() {
  const [search, setSearch] = useQueryState('q', parseAsString.withDefault(''))
  const [page, setPage] = useQueryState('page', parseAsInteger.withDefault(1))
  const [activeTab, setActiveTab] = useQueryState('tab', parseAsStringEnum(tabs).withDefault('overview'))
  
  return { search, setSearch, page, setPage, activeTab, setActiveTab }
}

// Or use useQueryStates for multiple related URL params
export function useFilters() {
  const [filters, setFilters] = useQueryStates({
    search: parseAsString.withDefault(''),
    page: parseAsInteger.withDefault(1),
    sort: parseAsString.withDefault('name'),
  })
  
  return { filters, setFilters }
}
```

**When to use `nuqs`:**
- Search/filter state
- Tab/panel selection
- Pagination state
- Sort/filter options
- View preferences (grid/list, theme)
- Modal state (if shareable/bookmarkable)
- Any state that benefits from being shareable via URL

See [Frontend Stack](./stack.mdc) for more nuqs examples and patterns.

### Loading/Error State Management

For loading spinners, tooltips, and ephemeral flags from async operations, rely on TanStack Query's built-in state management.

❌ **Don't**: Manually manage loading/error states
```tsx
// Bad - manually managing loading/error state
const [isLoading, setIsLoading] = useState(false)
const [error, setError] = useState<Error | null>(null)

const fetchData = async () => {
  setIsLoading(true)
  setError(null)
  try {
    const data = await api.fetch()
    // use data
  } catch (err) {
    setError(err)
  } finally {
    setIsLoading(false)
  }
}
```

✅ **Do**: Use TanStack Query's built-in state
```tsx
// Good - TanStack Query provides loading/error state automatically
import { useQuery } from '@tanstack/react-query'
import { articles } from '@/queries/articles'

const { data, isLoading, isError, error } = useQuery(articles.all)

// Or for one-off async operations, use useAsyncFn
import { useAsyncFn } from 'react-use'

const [saveState, saveData] = useAsyncFn(async (data) => {
  return await api.save(data)
}, [])

// Access loading/error automatically: saveState.loading, saveState.error
```

**Never manually manage `isLoading`, `error`, or `isError` states** - these are provided automatically by TanStack Query hooks or `useAsyncFn`. See [React Hooks Rules](./react-hooks.mdc) for detailed patterns.

### Grouping Related State

When multiple state variables are consistently updated together, consolidate them into a single state object using `useSetState` from `react-use`. This simplifies state updates and reduces boilerplate.

❌ **Don't**: Use multiple `useState` calls for related state
```tsx
// Bad
const [message, setMessage] = useState('')
const [signedMessage, setSignedMessage] = useState<string | null>(null)
const [txTo, setTxTo] = useState('')
const [txAmount, setTxAmount] = useState('')
const [showBalance, setShowBalance] = useState(false)
const [addressError, setAddressError] = useState<string | null>(null)
const [amountError, setAmountError] = useState<string | null>(null)

// Updating multiple states requires multiple calls
const handleSuccess = () => {
  setSignedMessage(data.signedMessage)
  setMessage('')
}
```

✅ **Do**: Use `useSetState` for grouped state
```tsx
// Good
import { useSetState } from 'react-use'

interface FormState {
  message: string
  signedMessage: string | null
  txTo: string
  txAmount: string
  showBalance: boolean
  addressError: string | null
  amountError: string | null
}

const [state, setState] = useSetState<FormState>({
  message: '',
  signedMessage: null,
  txTo: '',
  txAmount: '',
  showBalance: false,
  addressError: null,
  amountError: null,
})

// Update multiple properties atomically
const handleSuccess = () => {
  setState({ signedMessage: data.signedMessage, message: '' })
}

// Partial updates are easy
setState({ txTo: value, addressError: null })
```

**When to use `useSetState`:**
- Multiple related state variables updated together
- Form state with multiple fields (temporary, not shareable)
- UI state that changes together (modals, panels, etc.) - **only if not URL-shareable**
- Game/app state with multiple related properties (game engine state)
- Ephemeral UI state that doesn't belong in URL

**When NOT to use `useSetState`:**
- URL-shareable state (use `nuqs` instead)
- Loading/error states from async operations (use TanStack Query's built-in state)

**When to keep separate `useState`:**
- Completely independent state variables (rare, prefer other options)
- Simple boolean flags (only if truly independent and not URL-shareable)
- Single primitive values with no relation to other state (rare, prefer other options)

## Error Boundaries

Use `react-error-boundary` to catch React errors and provide fallback UI. Error boundaries catch errors during rendering, in lifecycle methods, and in constructors of the whole tree below them.

### Basic Error Boundary

```tsx
import { ErrorBoundary } from 'react-error-boundary'

function ErrorFallback({ error, resetErrorBoundary }: { error: Error; resetErrorBoundary: () => void }) {
  return (
    <div role="alert">
      <h2>Something went wrong:</h2>
      <pre>{error.message}</pre>
      <button onClick={resetErrorBoundary}>Try again</button>
    </div>
  )
}

export function App() {
  return (
    <ErrorBoundary FallbackComponent={ErrorFallback}>
      <YourApp />
    </ErrorBoundary>
  )
}
```

### Error Boundary with Reset

```tsx
import { ErrorBoundary } from 'react-error-boundary'

function ErrorFallback({ error, resetErrorBoundary }: { error: Error; resetErrorBoundary: () => void }) {
  return (
    <div role="alert">
      <h2>Something went wrong</h2>
      <p>{error.message}</p>
      <button onClick={resetErrorBoundary}>Try again</button>
    </div>
  )
}

export function App() {
  return (
    <ErrorBoundary
      FallbackComponent={ErrorFallback}
      onReset={() => {
        // Reset app state, clear cache, etc.
        window.location.reload()
      }}
      resetKeys={['someKey']} // Reset when this key changes
    >
      <YourApp />
    </ErrorBoundary>
  )
}
```

### Async Error Handling

Use `useErrorHandler` hook for async errors (promises, callbacks, etc.):

```tsx
import { useErrorHandler } from 'react-error-boundary'

function MyComponent() {
  const handleError = useErrorHandler()

  const handleAsyncOperation = async () => {
    try {
      await someAsyncOperation()
    } catch (error) {
      handleError(error) // This will trigger the nearest ErrorBoundary
    }
  }

  return <button onClick={handleAsyncOperation}>Do something</button>
}
```

### When to Use Error Boundaries

✅ **Use error boundaries for:**
- App-level error handling (wrap root component)
- Section-level error handling (wrap independent sections)
- Feature-level error handling (wrap features that can fail independently)
- Third-party component errors

❌ **Don't use error boundaries for:**
- Event handlers (use try/catch instead)
- Async code (use `useErrorHandler` hook)
- Server-side rendering errors
- Errors during error boundary rendering itself

**Best Practices:**
- Place error boundaries at strategic points in your component tree
- Provide meaningful fallback UI
- Log errors to error tracking service
- Use `resetErrorBoundary` to allow recovery
- Consider different fallbacks for different error types

## Component Composition
- Use children prop for flexible composition
- Extract shared logic into custom hooks

## Accessibility
- Use semantic HTML elements
- Maintain proper color contrast

## Code Style
- See [TypeScript Rules](../base/typescript.mdc) for code style guidelines

## Related Rules
- See [React Hooks Rules](./react-hooks.mdc) for data fetching patterns
- See [Next.js Rules](./nextjs.mdc) for Next.js-specific patterns