---
description: Preferred frontend technology stack and library usage patterns
globs: *.tsx,*.ts
alwaysApply: false
---

# Frontend Stack

## Core Technologies

### Data Fetching & State Management
- **@tanstack/react-query**: Primary data fetching and caching solution
  - Use for all server data fetching
  - Implement proper query keys and invalidation strategies
  - Combine multiple queries into cohesive custom hooks
- **nuqs**: URL-based state management
  - Use for shareable, bookmarkable state
  - Decouples components from internal state logic
  - Prefer over local state when state should be in URL

### Ethereum Integration
- **viem**: Type-safe Ethereum interface
  - Low-level Ethereum interactions
  - Modern TypeScript API
  - Use for direct contract interactions
- **wagmi**: React hooks for Ethereum
  - Built on top of react-query and viem
  - Provides consistent data fetching patterns
  - Use for wallet connections and contract reads/writes

### Validation & Type Safety
- **zod**: Schema validation
  - Use for runtime type validation
  - Validate API responses and form inputs
  - Integrate with TypeScript for type inference

### Authentication & Actions
- **next-auth**: Authentication solution
  - Server-side session management
  - Secure authentication flows
- **next-safe-action**: Type-safe server actions
  - Use for all server actions
  - Provides type safety and error handling
  - Follow the ActionResult pattern with success/failure

### Utility Libraries
- **react-use**: React hooks library
  - Use `useAsync`/`useAsyncFn` for one-off async operations
  - Prefer TanStack Query for data fetching
  - Use for non-data-fetching async operations
- **lodash**: Utility functions
  - Use sparingly, prefer native JavaScript when possible
  - Import specific functions: `import debounce from 'lodash/debounce'`

## Usage Patterns

### Data Fetching with TanStack Query
```tsx
import { useQuery, useMutation } from '@tanstack/react-query'

export function useUserData(userId: string) {
  return useQuery({
    queryKey: ['user', userId],
    queryFn: async () => {
      const data = await fetchUser(userId)
      return data
    }
  })
}
```

### URL State with nuqs
```tsx
import { useQueryState } from 'nuqs'

export function useSearchFilter() {
  const [search, setSearch] = useQueryState('q', {
    defaultValue: '',
    clearOnDefault: true
  })
  return { search, setSearch }
}
```

### Ethereum with wagmi
```tsx
import { useAccount, useReadContract } from 'wagmi'

export function useUserBalance(address: string) {
  const { address: userAddress } = useAccount()
  return useReadContract({
    address: contractAddress,
    abi: contractAbi,
    functionName: 'balanceOf',
    args: [userAddress]
  })
}
```

### Validation with zod
```tsx
import { z } from 'zod'

const userSchema = z.object({
  name: z.string().min(1),
  email: z.string().email()
})

type User = z.infer<typeof userSchema>
```

## Best Practices

- **Prefer TanStack Query** over react-use for data fetching
- **Use nuqs** for state that should be shareable via URL
- **Validate all external data** with zod schemas
- **Type-safe server actions** with next-safe-action
- **Import utilities selectively** to reduce bundle size
- **Combine related queries** into cohesive custom hooks
- **Follow fractal component patterns** for consistent structure
