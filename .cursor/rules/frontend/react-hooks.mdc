---
description: React hooks patterns and best practices
alwaysApply: false
---
# React Hooks Rules

## Core Principles
- Use TanStack Query for data fetching
- Use `useAsyncFn` for one-off async operations
- Follow hooks naming: `use-kebab-case.ts`

## TanStack Query Patterns

### Query Key Factory Pattern (CRITICAL)
Always use `@lukemorales/query-key-factory` for centralized, type-safe query keys.

**File Organization**: `src/queries/articles.ts` - Query key factory for articles, `src/queries/users.ts` - Query key factory for users, `src/queries/index.ts` - Re-export all query keys

**Create Query Key Factory**:
```tsx
import { createQueryKeys } from '@lukemorales/query-key-factory'

export const articles = createQueryKeys('articles', {
  all: { queryKey: null, queryFn: fetchArticles },
  detail: (id: string) => ({ queryKey: [id], queryFn: () => fetchArticleById(id) }),
})
```

**Using in Queries**:
```tsx
import { useQuery } from '@tanstack/react-query'
import { articles } from '@/queries/articles'
const { data, isLoading, error } = useQuery(articles.detail(id))
```

**Query Options**:
```tsx
const { data } = useQuery({
  ...articles.detail(id),
  staleTime: 5 * 60 * 1000,
  gcTime: 10 * 60 * 1000,
  retry: 3,
  retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
})
```

**Dependent Queries**:
```tsx
const { data: user } = useQuery(users.detail(userId))
const { data: posts } = useQuery({ ...posts.byUser(userId), enabled: !!user })
```

**Mutations with Invalidation**:
```tsx
import { useMutation, useQueryClient } from '@tanstack/react-query'
const queryClient = useQueryClient()
const mutation = useMutation({
  mutationFn: createArticle,
  onSuccess: () => {
    queryClient.invalidateQueries({ queryKey: articles._def })
  },
})
```

**Optimistic Updates**:
```tsx
const mutation = useMutation({
  mutationFn: updateArticle,
  onMutate: async (newArticle) => {
    await queryClient.cancelQueries({ queryKey: articles.detail(newArticle.id).queryKey })
    const previous = queryClient.getQueryData(articles.detail(newArticle.id).queryKey)
    queryClient.setQueryData(articles.detail(newArticle.id).queryKey, newArticle)
    return { previous }
  },
  onError: (err, newArticle, context) => {
    if (context?.previous) {
      queryClient.setQueryData(articles.detail(newArticle.id).queryKey, context.previous)
    }
  },
  onSettled: () => {
    queryClient.invalidateQueries({ queryKey: articles._def })
  },
})
```

**Infinite Queries**:
```tsx
export const articles = createQueryKeys('articles', {
  infinite: (filters: ArticleFilters) => ({
    queryKey: ['infinite', filters],
    queryFn: ({ pageParam = 0 }) => fetchArticlesPage({ ...filters, page: pageParam }),
  }),
})
const { data, fetchNextPage, hasNextPage } = useInfiniteQuery(articles.infinite(filters))
```

**Suspense Integration**:
```tsx
import { useSuspenseQuery } from '@tanstack/react-query'
function Article({ id }: { id: string }) {
  const { data } = useSuspenseQuery(articles.detail(id))
  return <div>{data.title}</div>
}
```

### Anti-Patterns
❌ **Don't**: Manually construct query keys `useQuery({ queryKey: ['articles', id] })`
✅ **Do**: Use query key factory `useQuery(articles.detail(id))`

❌ **Don't**: Hardcode query keys in invalidations `queryClient.invalidateQueries({ queryKey: ['articles'] })`
✅ **Do**: Use namespace invalidation `queryClient.invalidateQueries({ queryKey: articles._def })`

## Async Operations
**Use TanStack Query for**: Server data fetching, data that needs caching, mutations and optimistic updates

**Use `useAsyncFn` from `react-use` for**: One-off async operations (file uploads, form submissions without caching), non-data-fetching async operations

See @.cursor/rules/frontend/react.mdc for state management decision tree and when to use each pattern.

## Memoization Hooks
**Default: Don't use `useMemo` or `useCallback`** - Modern React optimizations (React 19.2.3 with Fiber) handle most cases automatically.

### When Memoization is Actually Needed
**In custom hooks, only use memoization when**:
1. **Returning stable function references** - When hook consumers need stable function identity AND dependencies are stable
2. **Expensive computations in hooks** - When hook performs genuinely expensive work
3. **Context provider values** - When hook creates context value for provider

### When NOT to Use Memoization in Hooks
**Remove memoization from custom hooks when**:
1. **Dependencies change frequently** - Memoization becomes ineffective
2. **Simple operations** - Array operations, object creation, simple conditionals
3. **useEffect dependencies** - If callback depends on frequently changing state, memoization doesn't help

### Best Practices for Custom Hooks
- **Start without memoization** - Add only when profiling reveals bottlenecks
- **Prefer primitive dependencies** - Use primitive values in useEffect dependencies instead of memoized functions
- **Trust React's optimizations** - Modern React handles function recreation efficiently
- **Profile first** - Only add memoization when you measure actual performance issues

See @.cursor/rules/frontend/react.mdc for complete memoization guidelines, anti-patterns, and examples.

## Custom Hooks Best Practices
- Combine multiple queries into cohesive hooks
- Extract query logic into custom hooks for reusability
- Use query key factory for all TanStack Query hooks
- Never manually manage `isLoading`, `error`, or `isError` states

## Related
- @.cursor/rules/frontend/react.mdc - Component patterns
- @.cursor/rules/frontend/stack.mdc - Library usage patterns
- @.cursor/rules/base/typescript.mdc - Type safety patterns
