---
description: NestJS backend development standards and patterns
globs: *.ts,**/*module.ts,**/*service.ts,**/*controller.ts
alwaysApply: false
---
# NestJS Rules

## Module Structure
- Organize code by domain/feature modules
- Keep modules focused and single-purpose

## Development Workflow

**Development uses `tsx watch` for fast TypeScript execution:**
- `pnpm start:dev` runs `tsx watch src/main.ts` (development mode)
- `pnpm start:staging` runs `tsx watch src/main.ts` (staging mode)
- `pnpm start:debug` runs `tsx watch src/main.ts` with `--inspect` flag
- Production uses `node dist/main.js` (built CJS output)

**Benefits:**
- Faster startup than Nest CLI + ts-node
- Direct TypeScript execution without compilation step
- Better error messages and debugging support
- No loader configuration needed

## ESM (ECMAScript Modules) Support

**All NestJS apps use ESM** - ensure `package.json` includes `"type": "module"`.

### Import Extensions
- **Relative imports do NOT require `.js` extensions** (bundler mode handles resolution)
- TypeScript bundler mode resolves imports automatically
- Example: `import { x } from './file'` (clean imports without extensions)
- Barrel files (`index.ts`) work without extensions: `export * from './module'`

### CommonJS Pattern Conversions
- **Never use `__dirname` or `__filename`** - use ESM pattern instead:
  ```typescript
  import { fileURLToPath } from 'node:url'
  import { dirname } from 'node:path'
  
  const __filename = fileURLToPath(import.meta.url)
  const __dirname = dirname(__filename)
  ```
- **Never use `require()`** - use dynamic `import()` instead:
  ```typescript
  // For loading compiled modules dynamically
  import { pathToFileURL } from 'node:url'
  
  const moduleUrl = pathToFileURL(join(__dirname, '../dist/app.module.js')).href
  const { AppModule } = await import(moduleUrl)
  ```

## API Design
- Use DTOs with class-validator for input validation
  - **DTOs (Data Transfer Objects)** in NestJS controllers should use `class-validator` decorators
  - This is the NestJS standard and exception to the zod preference
- Use zod for all other schemas (tool parameters, environment variables, internal validation)
- Document APIs with Swagger/OpenAPI

## Utility Libraries
- **@vencura/lib**: Shared utility library for common operations
  - **Error utilities**: Use `sanitizeErrorMessage` in exception filters for production error sanitization
  - **Async utilities**: Use `fetchWithTimeout` for external API calls (addresses security LOW-003)
  - **Error handling**: Use `getErrorMessage` to extract error messages consistently
  - Import from `@vencura/lib`: `import { sanitizeErrorMessage, fetchWithTimeout } from '@vencura/lib'`

## Database Access
- Use the repository pattern for database operations
- Use Drizzle for database interactions
- Optimize database queries for performance

## AI/Streaming Integration
- **@ai-sdk/core**: Use for provider-agnostic AI integration
  - Use `streamText` for streaming chat responses
  - Use `tool()` function for defining AI tools
  - Support both streaming and non-streaming modes
- **Server-Sent Events (SSE)**: Implement streaming responses
  - Use `@Res()` decorator with Express Response
  - Set proper headers: `Content-Type: text/event-stream`, `Cache-Control: no-cache`, `Connection: keep-alive`
  - Stream chunks with `data: {json}\n\n` format
  - End stream with `data: [DONE]\n\n`
- **Tool Definitions**: Expose API endpoints as AI tools
  - Use Zod schemas for tool parameters
  - Wrap existing service methods
  - Handle errors and return structured responses
  - Pass user context for authorization

## Environment Variables

### File Structure Pattern

All NestJS apps follow a consistent environment variable pattern:

**Files:**
- `.env` - Sensitive data (API keys, tokens, secrets) - **NEVER COMMIT**
- `.env.development` - Development configuration (committed, non-sensitive)
- `.env.staging` - Staging configuration (committed, non-sensitive)
- `.env.production` - Production configuration (committed, non-sensitive)
- `.env-example` - Template for `.env` file (shows required sensitive variables)

**Loading Priority (highest to lowest):**
1. `.env` (sensitive data, never committed, overrides everything)
2. `.env.development` / `.env.staging` / `.env.production` / `.env.test` (based on NODE_ENV, committed configs)

**Manual Loading Required:**
NestJS requires manual loading via `loadEnv()` function (see `src/config/load-env.ts`). Call this before app initialization.

**ESM Pattern for load-env.ts:**
```typescript
import { config } from 'dotenv'
import { resolve } from 'path'
import { fileURLToPath } from 'node:url'
import { dirname } from 'node:path'

const __filename = fileURLToPath(import.meta.url)
const __dirname = dirname(__filename)

export function loadEnv(): void {
  const nodeEnv = process.env.NODE_ENV || 'development'
  const envDir = resolve(__dirname, '../../')
  // ... rest of implementation
}
```

### Validation Pattern

Always use Zod for environment variable validation:

```typescript
import { z } from 'zod'

const envSchema = z.object({
  DYNAMIC_ENVIRONMENT_ID: z.string().min(1, 'DYNAMIC_ENVIRONMENT_ID is required'),
  DYNAMIC_API_TOKEN: z.string().min(1, 'DYNAMIC_API_TOKEN is required'),
  ENCRYPTION_KEY: z.string().min(32, 'ENCRYPTION_KEY must be at least 32 characters'),
  PORT: z.string().regex(/^\d+$/).default('3077').transform(val => parseInt(val, 10)).pipe(z.number().int().positive()),
})

export type EnvSchema = z.infer<typeof envSchema>

export function validateEnv({ env = process.env }: { env?: NodeJS.ProcessEnv } = {}) {
  const result = envSchema.safeParse(env)
  if (!result.success) {
    const errors = result.error.errors.map(err => `${err.path.join('.')}: ${err.message}`).join('\n')
    throw new Error(`Environment validation failed:\n${errors}`)
  }
  return result.data
}
```

**Key Points:**
- Use Zod schemas for all environment variable validation
- Define explicit return types for validation functions
- Use `.default()` for optional fields with defaults
- Use `.transform()` and `.pipe()` for type coercion
- Throw errors with clear messages on validation failure

## Testing
- Implement API testing, input output validation