---
description: Solidity development standards with Foundry
globs: **/contracts/**/*.sol,*.sol
alwaysApply: false
---
# Solidity & Foundry Rules

## Core Principles
- Use latest stable Solidity version (^0.8.20)
- Use custom errors instead of revert strings (when validation is needed)
- For test contracts with intentionally open access (e.g., faucet tokens), custom errors may not be necessary

## Foundry Dependencies

- **Never manually edit files in `lib/` directory**: The `lib/` directory contains third-party dependencies (e.g., OpenZeppelin Contracts) managed by Foundry
- **Update dependencies via Foundry**: Use `forge update` or `pnpm run deps:update` to update dependencies
- **Formatting protection**: The `lib/` directory is excluded from formatting via `foundry.toml` (`[fmt] exclude = ["lib/**"]`) and `.prettierignore`
- **Dependency management**: All dependencies are installed and updated through Foundry's dependency system (`forge install`, `forge update`)

## Contract Structure
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {ReentrancyGuard} from "@openzeppelin/contracts/security/ReentrancyGuard.sol";

error Unauthorized();
error InvalidAmount();

contract ExampleContract is Ownable, ReentrancyGuard {
    // Events
    event Deposited(address indexed user, uint256 amount);
    
    // State variables
    uint256 public constant MIN_DEPOSIT = 0.1 ether;
    mapping(address => uint256) public balances;
    
    // Functions
    function deposit() external payable nonReentrant {
        // Checks
        if (msg.value < MIN_DEPOSIT) revert InvalidAmount();
        
        // Effects
        balances[msg.sender] += msg.value;
        
        // Interactions
        emit Deposited(msg.sender, msg.value);
    }
}
```

## Gas Optimization
- Use unchecked blocks for safe math operations
- Pack storage variables efficiently
- Cache storage variables in memory

```solidity
contract GasOptimized {
    // Pack related variables
    struct UserInfo {
        uint96 balance;
        uint96 stakedAmount;
        uint64 lastUpdate;
    }
}
```

## Test Token Patterns

For test tokens and faucet contracts (e.g., DNMC, mocked USDC/USDT):

- **Reuse existing contracts**: Use `TestToken.sol` with separate deployment scripts rather than creating duplicate contracts
- **Open minting/burning**: Test tokens may have intentionally open access controls for faucet functionality
- **Configurable decimals**: Support different decimal values (6 for stablecoins, 18 for utility tokens)
- **Deployment scripts**: Create separate scripts for each token (e.g., `DNMC.s.sol`, `USDC.s.sol`, `USDT.s.sol`) that configure the same base contract
- **Environment variables**: Use `vm.envOr()` and `vm.envUint()` for configuration with sensible defaults
- **Documentation**: Clearly mark mocked/test tokens as such in documentation to avoid confusion with real tokens