---
description: Logging best practices and rules
alwaysApply: false
---
# Logging Rules

## Never Use console.* Directly
**Never use `console.log`, `console.error`, `console.warn`, or `console.info` in app code.**

Always use unified logger from `@repo/utils/logger`:
```typescript
import { logger } from '@repo/utils/logger'
logger.info('User logged in', { userId })
logger.error('Failed to fetch data', { error })
```

## Unified Logger API
Works consistently across server and client:
```typescript
import { logger } from '@repo/utils/logger'

logger.debug('Debug message', { data })
logger.info('Info message', { userId: '123' })
logger.warn('Warning message', { remaining: 10 })
logger.error('Error message', { error })

// Child logger with bindings
const requestLogger = logger.child({ requestId: 'abc-123', userId: 'user-456' })
requestLogger.info('Processing request') // Includes requestId and userId
```

**Build-time conditional exports**: No runtime detection. See @apps/docu/content/docs/architecture/logging.mdx

## Log Levels
- **`debug`**: Detailed debugging info (development only)
- **`info`**: General informational messages
- **`warn`**: Warning messages for potentially harmful situations
- **`error`**: Error messages for failures

## Best Practices
- **Structured fields**: `logger.info({ userId, action: 'login' }, 'User logged in')` not string interpolation
- **Request ID correlation**: Use `child()` for request-scoped loggers
- **Never log secrets**: Server-side logger auto-redacts common secret fields, but avoid logging sensitive data
- **Error logging**: Always include error objects: `logger.error({ error, context }, 'Failed to process order')`

## Environment Configuration
**Server-side**: `LOG_ENABLED`, `LOG_LEVEL` (debug/info/warn/error/silent), `LOG_SERVICE`

**Client-side**: `NEXT_PUBLIC_LOG_ENABLED`, `NEXT_PUBLIC_LOG_LEVEL` (disabled in prod by default)

## Runtime Differences
- **Server-side**: Pino for structured JSON logging with automatic secret redaction
- **Client-side**: Console wrapper with environment-controlled enable/level filtering

Same API works in both - conditional exports handle selection at build time.

## Fastify Integration
Use either:
1. **Fastify's request logger**: `request.log.info('Processing request')` (includes request context)
2. **Shared logger with child bindings**: `const requestLogger = logger.child({ requestId: request.id })`

**Error logging with captureError**: Pass `logger: request.log` to use Fastify's native logger for request context.

## Related
- @apps/docu/content/docs/architecture/logging.mdx - Complete logging documentation
- @.cursor/rules/base/environment.mdc - Environment variable patterns
