---
description: TypeScript coding standards and best practices
globs: *.tsx,*.ts
alwaysApply: false
---
# TypeScript Rules

## Tooling
- Use **pnpm** for package management (not bun, npm, or yarn)
- Use **eslint + prettier** for linting and formatting
- Run `pnpm format` to format code, `pnpm run lint` to lint code

## Core Principles
- Prefer interfaces over types for object definitions
  - **Exception**: Union types, utility types (e.g., `z.infer<typeof schema>`), and mapped types should use `type`
  - **Example**: `interface User { id: string }` ✅ vs `type User = { id: string }` ❌
  - **Example**: `type ChainType = 'evm' | 'solana'` ✅ (union type)
  - **Example**: `type EnvSchema = z.infer<typeof envSchema>` ✅ (utility type)
- Avoid enums; use maps or union types instead
- Use descriptive variable names with auxiliary verbs (e.g., `isLoading`, `hasError`)
- Follow the RORO (Receive an Object, Return an Object) pattern for function arguments **only when there are multiple parameters**; single-parameter functions use direct parameters
- Use lowercase-with-dashes for directories (e.g., `components/auth-wizard`)
- Favor named exports for components
  - **Exception**: Next.js pages (`app/**/page.tsx`) and layouts (`app/**/layout.tsx`) require default exports
- Use functional & declarative programming patterns; avoid classes
- Infer types and keep them inline unless you need to reuse them

## Type Inference Enforcement

**Critical Rule**: Always enforce type inference - define return types in functions when needed, never in consumers.

### Function Definitions

**Function Declaration Style:**

- **NEVER use `const` for function definitions. ALWAYS USE `function` declarations for all exported functions**
  - ✅ **Good**: `export function createClient(): Client { ... }`
  - ❌ **Bad**: `export const createClient = (): Client => { ... }`
  - ❌ **Bad**: `export const createClient = function(): Client { ... }`
  - **Rationale**: Function declarations are hoisted, more readable, and align with the codebase's functional programming style

**Return Type Rules:**

- **Simple functions** (single-expression returns, one-liners, pure functions): Can rely on type inference
  - ✅ **Good**: `const double = (x: number) => x * 2` (inferred)
  - ✅ **Good**: `const getValue = () => someValue` (inferred)
  - ✅ **Good**: `const format = (str: string) => str.trim().toLowerCase()` (inferred)

- **Complex functions** (multiple return paths, async operations, complex logic): MUST have explicit return types
  - ✅ **Good**: `async function fetchData(): Promise<Data> { ... }`
  - ✅ **Good**: `function process(input: string): Result | null { ... }`
  - ✅ **Good**: `function validate(data: unknown): ValidationResult { if (...) return ...; return ... }`

- **Exported/public functions**: Prefer explicit return types for API clarity and documentation
  - ✅ **Good**: `export function getUser(id: string): User { ... }`
- **@vencura/lib functions**: MUST always have explicit return types - no exceptions
  - ✅ **Good**: `export function delay(ms: number): Promise<void> { ... }`
  - ✅ **Good**: `export function getErrorMessage(error: unknown): string | null { ... }`
  - ❌ **Bad**: `export const delay = (ms: number) => new Promise(...)` (missing return type, wrong declaration style)
  - **Rationale**: Consumers should never need to cast types when using @vencura/lib functions
- **ALL exported functions from @vencura packages** (except React components): MUST have explicit return types - no exceptions
  - ✅ **Good**: `export function createClient(): Client { ... }`
  - ✅ **Good**: `export function useVencuraClient(): VencuraClient { ... }`
  - ✅ **Good**: `export function useMintToken(): UseMutationResult<...> { ... }`
  - ❌ **Bad**: `export function createClient() { ... }` (missing return type)
  - ❌ **Bad**: `export function useMintToken(): ReturnType<typeof useMutation<...>> { ... }` (should use explicit type, not ReturnType)
  - **Rationale**: Explicit return types ensure consumers never need type assertions, casting, or parsing

- **React components**: NEVER have explicit return types - always rely on inference
  - ✅ **Good**: `export function Component() { return <div>...</div> }` (inferred JSX.Element)
  - ❌ **Bad**: `export function Component(): JSX.Element { ... }` (redundant)
  - ❌ **Bad**: `export const Component: React.FC<Props> = () => { ... }` (avoid React.FC, wrong declaration style)

- **React hooks (non-component functions)**: MUST have explicit return types
  - ✅ **Good**: `export function useVencuraClient(): VencuraClient { ... }`
  - ✅ **Good**: `export function useMintToken(): UseMutationResult<SendTransactionResult, Error, MintTokenInput> { ... }`
  - ✅ **Good**: `export function useTokenBalance(): UseQueryResult<TokenBalance, Error> { ... }`
  - ❌ **Bad**: `export function useMintToken(): ReturnType<typeof useMutation<...>> { ... }` (should use explicit type)

- **Use `ReturnType<typeof function>` only in type definitions**, never as function return types
  - ✅ **Good**: `type Handler = ReturnType<typeof createHandler>` (in type definition)
  - ✅ **Good**: `export type VencuraClient = ReturnType<typeof createVencuraClient>` (in type definition)
  - ❌ **Bad**: `export function createClient(): ReturnType<typeof initClient> { ... }` (should use explicit return type)
  - ❌ **Bad**: `const handler: ReturnType<typeof createHandler> = createHandler()` (in consumer - should infer)

### Consumer Code
- **Consumers MUST infer types from function return values**: Never explicitly type variables that receive function results
  - ✅ **Good**: `const user = getUser(id)` (type inferred from `getUser` return type)
  - ✅ **Good**: `const response = await fetchWithTimeout({ url, options })` (type inferred)
  - ❌ **Bad**: `const user: User = getUser(id)` (redundant explicit type)
  - ❌ **Bad**: `const response: Promise<Response> = fetchWithTimeout({ url, options })` (should infer)
- **Never add explicit type imports just to help inference**: If TypeScript isn't resolving function types correctly, fix the function definition instead
  - ❌ **Bad**: Adding `import type { User } from './types'` just to type a consumer variable
  - ✅ **Good**: Ensure the function has an explicit return type, then let consumers infer
- **Never cast types on the consumer side**: Types should be inferred from function return values, primarily from `@vencura/types`, `@vencura/core`, `@vencura/react`, and `@vencura/lib`
  - ✅ **Good**: `const { data: wallets } = useWallets()` (inferred Wallet[] from @vencura/react)
  - ✅ **Good**: `const wallet = await client.wallet.create({ body })` (inferred Wallet from @vencura/core)
  - ✅ **Good**: `const message = getErrorMessage(error)` (inferred string | null from @vencura/lib)
  - ✅ **Good**: `const env = validateEnv({ schema })` (inferred result type from @vencura/lib)
  - ❌ **Bad**: `const { data: wallets }: { data: Wallet[] } = useWallets()` (redundant type annotation)
  - ❌ **Bad**: `const wallet: Wallet = await client.wallet.create({ body })` (should infer)
  - ❌ **Bad**: `const message = getErrorMessage(error) as string` (should never need casting with @vencura/lib)
  - ❌ **Bad**: `const transactionInput: SendTransactionInput = { ... }` (should infer from function/object literal)

### Examples

**Correct Pattern**:
```typescript
// Function defines return type
export async function fetchWithTimeout({
  url,
  options = {},
  timeoutMs = 5000,
}: {
  url: string
  options?: RequestInit
  timeoutMs?: number
}): Promise<Response> {
  // ... implementation
}

// Consumer infers type
const response = await fetchWithTimeout({ url: 'https://api.example.com' })
// response is inferred as Promise<Response>
```

**Incorrect Pattern**:
```typescript
// Function missing return type
export async function fetchWithTimeout({ url, options }: Params) {
  // ... implementation
}

// Consumer trying to help inference (WRONG)
const response: Promise<Response> = await fetchWithTimeout({ url })
// Should fix the function definition instead
```

### Why This Matters
- **Single source of truth**: Return types are defined once in the function, not duplicated in consumers
- **Better maintainability**: Changing a function's return type automatically updates all consumers
- **Type safety**: TypeScript's inference is powerful - trust it instead of fighting it
- **Code clarity**: Explicit types in consumers add noise and can become stale

## Framework Exceptions
- **NestJS**: Classes are required for decorators (@Injectable, @Controller, etc.), so the "avoid classes" rule doesn't apply to NestJS services/controllers
- **RORO Pattern**: Applies to utility functions, not NestJS method signatures (which use decorators)
- **Next.js**: Pages (`app/**/page.tsx`) and layouts (`app/**/layout.tsx`) require default exports for framework routing

## Code Style
- **Enforce single-line if statements without brackets**: Use `if(cond) do()` or `cond && do()` for one-liners
  - **Example**: `if (!value) return null` ✅ vs `if (!value) { return null }` ❌
  - **Example**: `if (isLoading) return <Spinner />` ✅
  - Multi-line if statements must use brackets
- **Enforce single-line arrow functions without brackets**: Use `() => expr` for one-liners
  - **Example**: `const double = (x: number) => x * 2` ✅ vs `const double = (x: number) => { return x * 2 }` ❌
- Always use the less amount chars possible when writing code, while maintaining simplicity
- Prefer one-liners for simple conditional logic
- Avoid unnecessary curly braces in conditionals

## ESLint Rules
The following ESLint rules enforce these codestyle guidelines:
- `curly: "off"` - Allows single-line if statements without brackets
- `arrow-body-style: ["error", "as-needed"]` - Enforces arrow functions without brackets when possible
- `semi: ["error", "never"]` - Enforces no semicolons
- `@typescript-eslint/consistent-type-definitions: ["error", "interface"]` - Prefers interfaces over types
- `import/no-default-export: "error"` - Enforces named exports (with Next.js exceptions)
- `react/jsx-no-leaked-render: ["error", { validStrategies: ["ternary"] }]` - Prefers ternaries over && in JSX

## Utility Libraries
- **@vencura/lib**: Shared utility library for common operations
  - **Async utilities**: `delay`, `fetchWithTimeout`
  - **Error utilities**: `getErrorMessage`, `formatZodError`, `sanitizeErrorMessage`, `isZodError`
  - **Date utilities**: `getDateKey`
  - **Environment utilities**: `validateEnv`, `validateEnvOrThrow`, `getEnvHelper`
  - **Zod utilities**: `formatZodErrors`, `parseJsonWithSchema`
  - Import from `@vencura/lib`: `import { delay, getErrorMessage } from '@vencura/lib'`
  - **Prefer @vencura/lib over custom implementations** for these utilities
  - **Critical**: All @vencura/lib functions MUST return explicit types - consumers should never need type casting
    - ✅ **Good**: `const message = getErrorMessage(error)` (type inferred as `string | null`)
    - ❌ **Bad**: `const message: string | null = getErrorMessage(error)` (redundant - should infer)
    - ❌ **Bad**: `const message = getErrorMessage(error) as string` (should never need casting)
- **Prefer lodash over custom implementations** for common operations
  - Use lodash for array manipulation (`isEmpty`, `uniq`, `groupBy`, `chunk`)
  - Use lodash for object operations (`merge`, `pick`, `omit`, `isEmpty`)
  - Use lodash for type checking (`isString`, `isNumber`, `isEmpty`, `isPlainObject`)
  - Use lodash for string transformations (`camelCase`, `kebabCase`, `startCase`)
  - Use lodash for functional utilities (`debounce`, `throttle`, `memoize`)
  - Import specific functions: `import { isEmpty, uniq } from 'lodash'`
- **Use zod for schema validation** (except NestJS DTOs which use class-validator)
  - All schemas should use zod for runtime validation and type inference
  - NestJS DTOs are the exception - they correctly use `class-validator` per NestJS conventions
  - Use zod for environment variables, API responses, form validation, and tool parameters
  - **Environment Variables**: Always use zod for env validation with `validateEnv` from `@vencura/lib`
    - Define env schema with zod: `const envSchema = z.object({ ... })`
    - Use `validateEnv({ schema: envSchema })` for validation
    - Infer types: `type Env = z.infer<typeof envSchema>`
    - All apps (Next.js, NestJS) should follow the same pattern
  - **Validation Functions**: Zod-based validation functions that return result objects must handle all errors gracefully
    - ✅ **Good**: Return `{ valid: boolean; error?: string }` for all error cases (Zod errors and unexpected errors)
    - ✅ **Good**: Use `isZodError` from `@vencura/lib` to check error types, then return consistent error objects
    - ❌ **Bad**: Rethrowing non-Zod errors breaks callers that expect result objects
    - **Example**: `validateAddressInput` returns `{ valid: false, error: '...' }` for all errors, never throws
    - **Exception**: Library functions designed to throw (e.g., `parseJsonWithSchema`) are fine - they're documented to throw

## ts-reset Type Safety

This monorepo uses `@total-typescript/ts-reset` to enhance TypeScript's built-in type safety. ts-reset is configured globally via `config/typescript/reset.d.ts` and is automatically included in all TypeScript configurations that extend `@workspace/typescript-config/base.json`, `@workspace/typescript-config/nextjs.json`, or `@workspace/typescript-config/react-library.json`.

**Configuration**: The `reset.d.ts` file imports `@total-typescript/ts-reset`, which applies type improvements across the entire monorepo. All apps and packages automatically benefit from these enhanced types.

### Key Type Improvements

- **`JSON.parse()` returns `unknown`**: Always validate parsed JSON data before use
  - ✅ **Good**: `const data = mySchema.parse(JSON.parse(jsonString))` (validate with zod)
  - ✅ **Good**: `const data = JSON.parse(jsonString) as Record<string, unknown>` (type assertion for test utilities)
  - ❌ **Bad**: `const data = JSON.parse(jsonString); const value = data.property` (TypeScript error: property doesn't exist on unknown)

- **`fetch().json()` returns `unknown`**: Always validate API responses before use
  - ✅ **Good**: `const data = await response.json(); const validated = mySchema.parse(data)` (validate with zod)
  - ✅ **Good**: `const data = (await response.json()) as Record<string, unknown>` (type assertion for test utilities)
  - ❌ **Bad**: `const data = await response.json(); const value = data.property` (TypeScript error: property doesn't exist on unknown)

- **`.filter(Boolean)` correctly filters falsy values**: Returns properly typed array without `undefined`, `null`, `false`, `0`, `NaN`, `""`
  - ✅ **Good**: `const numbers = [1, 2, undefined, 3].filter(Boolean)` (type: `number[]`)

- **`.includes()` on `as const` arrays**: Less strict type checking for array includes operations, making it more ergonomic to use

- **`.indexOf()` on `as const` arrays**: Less strict type checking for array indexOf operations

- **`Set.has()` and `Map.has()`**: Less strict type checking, making these methods more ergonomic

- **`Array.isArray()`**: Removes `any[]` from the return type, improving type safety

- **`localStorage` and `sessionStorage`**: Returns `unknown` instead of `string`, requiring explicit validation (when using DOM rules)

**Best Practice**: Since `JSON.parse()` and `response.json()` return `unknown`, always validate with zod schemas. This aligns with the monorepo's zod-first approach and ensures type safety at runtime. The zod-first validation strategy (see below) complements ts-reset by enforcing runtime validation at data boundaries.

**Reference**: See [ts-reset documentation](https://www.totaltypescript.com/ts-reset) for complete details on all type improvements.

## Type Safety Model: Zod-First Validation Strategy

This project uses a **Zod-first validation strategy** instead of relying on TypeScript ESLint's "unsafe" rules for type safety. The following TypeScript ESLint rules are intentionally disabled globally:

- `@typescript-eslint/no-unsafe-assignment`
- `@typescript-eslint/no-unsafe-call`
- `@typescript-eslint/no-unsafe-member-access`
- `@typescript-eslint/no-unsafe-return`
- `@typescript-eslint/no-unsafe-argument`

### Why These Rules Are Disabled

These rules are disabled because:

1. **AI-Assisted Development**: They are incompatible with AI-assisted development workflows and generate excessive noise around unavoidable `any` types that occur when working with external APIs, libraries, and frameworks.

2. **Runtime Validation Over Static Analysis**: Our safety model is based on **runtime validation** (Zod schemas), not static ESLint rules. We validate data at runtime boundaries where it enters our system, ensuring type safety through actual data validation rather than type assertions.

3. **Reduced Noise**: These rules create false positives and require numerous inline disables, cluttering code without providing meaningful safety guarantees.

### Our Type Safety Approach

Instead of relying on ESLint's unsafe rules, we enforce type safety through:

1. **Zod Schema Validation**: All external or untrusted data must be validated using Zod (or equivalent schemas) before being used. This includes:
   - API responses
   - Database reads
   - Webhook payloads
   - RPC calls
   - AI/LLM responses
   - User input
   - Environment variables

2. **Fully Typed Interfaces**: All internal modules should export fully typed interfaces, DTOs, or schemas to maintain strong type guarantees. Consumers can rely on type inference from these well-defined boundaries.

3. **Data Boundary Validation**: Data boundaries (where external data enters the system) must be validated at the edges using Zod schemas. Once validated, data flows through the system with full type safety.

4. **Type Inference**: We prefer type inference over explicit type annotations in consumer code. Functions define return types; consumers infer types from function return values.

### Validation Requirements

- **Never add inline `eslint-disable` comments** for unsafe rules - they are disabled globally
- **Always validate external data** with Zod schemas at data boundaries
- **Export typed interfaces** from internal modules for type safety
- **Trust type inference** - let TypeScript infer types from validated data and function return types
- **Validate, don't assert** - Use Zod's `.parse()` or `.safeParse()` instead of type assertions

### Example: Proper Validation Pattern

```typescript
// ✅ Good: Validate at the boundary
import { z } from 'zod'

const apiResponseSchema = z.object({
  id: z.string(),
  name: z.string(),
})

async function fetchUser(id: string): Promise<{ id: string; name: string }> {
  const response = await fetch(`/api/users/${id}`)
  const data = await response.json() // Returns unknown
  const validated = apiResponseSchema.parse(data) // Runtime validation
  return validated // Fully typed, safe to use
}

// ✅ Good: Consumer infers type
const user = await fetchUser('123') // Type inferred from function return type
```

## Error Handling
- Fail fast: Handle errors early using guard clauses & early returns
- Place the happy path last for improved readability
- Avoid unnecessary else statements; prefer `if-return` pattern
- Throw errors from `@repo/errors` for consistency
- **Zod-based validation functions**: Functions that return result objects (e.g., `{ valid: boolean; error?: string }`) must catch all errors and return consistent error objects instead of throwing
  - ✅ **Good**: `catch (error) { if (isZodError(error)) return { valid: false, error: ... }; return { valid: false, error: 'Unexpected validation error' } }`
  - ❌ **Bad**: `catch (error) { if (isZodError(error)) return { valid: false, error: ... }; throw error }` (breaks callers expecting result objects)
  - This ensures callers can safely check `.valid` without try/catch blocks

## File Structure & Organization
Maintain a structured and logical order when organizing files:
1. Main Component – The primary component that orchestrates logic and renders subcomponents
2. Subcomponents – Smaller, reusable components that support the main component
3. Helpers & Utilities – Functions or modules that provide reusable logic and utilities
4. Static Content – Non-code assets such as constants, images, or localization files
5. Types & Interfaces – Type definitions for TypeScript to ensure type safety and maintain consistency

## Related Rules
- See [React Rules](../frontend/react.mdc) for React-specific patterns
- See [React Hooks Rules](../frontend/react-hooks.mdc) for hooks and data fetching patterns
- See [Next.js Rules](../frontend/nextjs.mdc) for Next.js-specific patterns