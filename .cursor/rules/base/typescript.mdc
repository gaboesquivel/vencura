---
description: TypeScript coding standards and best practices
globs: *.tsx,*.ts
alwaysApply: false
---
# TypeScript Rules

## Tooling
- Use **pnpm** for package management (not bun, npm, or yarn)
- Use **eslint + prettier** for linting and formatting
- Run `pnpm format` to format code, `pnpm run lint` to lint code

## Core Principles
- Prefer interfaces over types for object definitions
  - **Exception**: Union types, utility types (e.g., `z.infer<typeof schema>`), and mapped types should use `type`
  - **Example**: `interface User { id: string }` ✅ vs `type User = { id: string }` ❌
  - **Example**: `type ChainType = 'evm' | 'solana'` ✅ (union type)
  - **Example**: `type EnvSchema = z.infer<typeof envSchema>` ✅ (utility type)
- Avoid enums; use maps or union types instead
- Use descriptive variable names with auxiliary verbs (e.g., `isLoading`, `hasError`)
- Follow the RORO (Receive an Object, Return an Object) pattern for function arguments **only when there are multiple parameters**; single-parameter functions use direct parameters
- Use lowercase-with-dashes for directories (e.g., `components/auth-wizard`)
- Favor named exports for components
  - **Exception**: Next.js pages (`app/**/page.tsx`) and layouts (`app/**/layout.tsx`) require default exports
- Use functional & declarative programming patterns; avoid classes
- Infer types and keep them inline unless you need to reuse them

## Type Inference Enforcement

**Critical Rule**: Always enforce type inference - define return types in functions when needed, never in consumers.

### Function Definitions

**Return Type Rules:**

- **Simple functions** (single-expression returns, one-liners, pure functions): Can rely on type inference
  - ✅ **Good**: `const double = (x: number) => x * 2` (inferred)
  - ✅ **Good**: `const getValue = () => someValue` (inferred)
  - ✅ **Good**: `const format = (str: string) => str.trim().toLowerCase()` (inferred)

- **Complex functions** (multiple return paths, async operations, complex logic): MUST have explicit return types
  - ✅ **Good**: `async function fetchData(): Promise<Data> { ... }`
  - ✅ **Good**: `function process(input: string): Result | null { ... }`
  - ✅ **Good**: `function validate(data: unknown): ValidationResult { if (...) return ...; return ... }`

- **Exported/public functions**: Prefer explicit return types for API clarity and documentation
  - ✅ **Good**: `export function getUser(id: string): User { ... }`
  - ✅ **Good**: `export const createClient = (config: Config): Client => { ... }`
- **@vencura/lib functions**: MUST always have explicit return types - no exceptions
  - ✅ **Good**: `export function delay(ms: number): Promise<void> { ... }`
  - ✅ **Good**: `export function getErrorMessage(error: unknown): string | null { ... }`
  - ❌ **Bad**: `export const delay = (ms: number) => new Promise(...)` (missing return type)
  - **Rationale**: Consumers should never need to cast types when using @vencura/lib functions

- **React components**: NEVER have explicit return types - always rely on inference
  - ✅ **Good**: `export function Component() { return <div>...</div> }` (inferred JSX.Element)
  - ❌ **Bad**: `export function Component(): JSX.Element { ... }` (redundant)
  - ❌ **Bad**: `export const Component: React.FC<Props> = () => { ... }` (avoid React.FC)

- **Use `ReturnType<typeof function>` only in function definitions**, not in consumers
  - ✅ **Good**: `type Handler = ReturnType<typeof createHandler>` (in type definition)
  - ❌ **Bad**: `const handler: ReturnType<typeof createHandler> = createHandler()` (in consumer)

### Consumer Code
- **Consumers MUST infer types from function return values**: Never explicitly type variables that receive function results
  - ✅ **Good**: `const user = getUser(id)` (type inferred from `getUser` return type)
  - ✅ **Good**: `const response = await fetchWithTimeout({ url, options })` (type inferred)
  - ❌ **Bad**: `const user: User = getUser(id)` (redundant explicit type)
  - ❌ **Bad**: `const response: Promise<Response> = fetchWithTimeout({ url, options })` (should infer)
- **Never add explicit type imports just to help inference**: If TypeScript isn't resolving function types correctly, fix the function definition instead
  - ❌ **Bad**: Adding `import type { User } from './types'` just to type a consumer variable
  - ✅ **Good**: Ensure the function has an explicit return type, then let consumers infer
- **Never cast types on the consumer side**: Types should be inferred from function return values, primarily from `@vencura/types`, `@vencura/core`, `@vencura/react`, and `@vencura/lib`
  - ✅ **Good**: `const { data: wallets } = useWallets()` (inferred Wallet[] from @vencura/react)
  - ✅ **Good**: `const wallet = await client.wallet.create({ body })` (inferred Wallet from @vencura/core)
  - ✅ **Good**: `const message = getErrorMessage(error)` (inferred string | null from @vencura/lib)
  - ✅ **Good**: `const env = validateEnv({ schema })` (inferred result type from @vencura/lib)
  - ❌ **Bad**: `const { data: wallets }: { data: Wallet[] } = useWallets()` (redundant type annotation)
  - ❌ **Bad**: `const wallet: Wallet = await client.wallet.create({ body })` (should infer)
  - ❌ **Bad**: `const message = getErrorMessage(error) as string` (should never need casting with @vencura/lib)
  - ❌ **Bad**: `const transactionInput: SendTransactionInput = { ... }` (should infer from function/object literal)

### Examples

**Correct Pattern**:
```typescript
// Function defines return type
export async function fetchWithTimeout({
  url,
  options = {},
  timeoutMs = 5000,
}: {
  url: string
  options?: RequestInit
  timeoutMs?: number
}): Promise<Response> {
  // ... implementation
}

// Consumer infers type
const response = await fetchWithTimeout({ url: 'https://api.example.com' })
// response is inferred as Promise<Response>
```

**Incorrect Pattern**:
```typescript
// Function missing return type
export async function fetchWithTimeout({ url, options }: Params) {
  // ... implementation
}

// Consumer trying to help inference (WRONG)
const response: Promise<Response> = await fetchWithTimeout({ url })
// Should fix the function definition instead
```

### Why This Matters
- **Single source of truth**: Return types are defined once in the function, not duplicated in consumers
- **Better maintainability**: Changing a function's return type automatically updates all consumers
- **Type safety**: TypeScript's inference is powerful - trust it instead of fighting it
- **Code clarity**: Explicit types in consumers add noise and can become stale

## Framework Exceptions
- **NestJS**: Classes are required for decorators (@Injectable, @Controller, etc.), so the "avoid classes" rule doesn't apply to NestJS services/controllers
- **RORO Pattern**: Applies to utility functions, not NestJS method signatures (which use decorators)
- **Next.js**: Pages (`app/**/page.tsx`) and layouts (`app/**/layout.tsx`) require default exports for framework routing

## Code Style
- **Enforce single-line if statements without brackets**: Use `if(cond) do()` or `cond && do()` for one-liners
  - **Example**: `if (!value) return null` ✅ vs `if (!value) { return null }` ❌
  - **Example**: `if (isLoading) return <Spinner />` ✅
  - Multi-line if statements must use brackets
- **Enforce single-line arrow functions without brackets**: Use `() => expr` for one-liners
  - **Example**: `const double = (x: number) => x * 2` ✅ vs `const double = (x: number) => { return x * 2 }` ❌
- Always use the less amount chars possible when writing code, while maintaining simplicity
- Prefer one-liners for simple conditional logic
- Avoid unnecessary curly braces in conditionals

## ESLint Rules
The following ESLint rules enforce these codestyle guidelines:
- `curly: "off"` - Allows single-line if statements without brackets
- `arrow-body-style: ["error", "as-needed"]` - Enforces arrow functions without brackets when possible
- `semi: ["error", "never"]` - Enforces no semicolons
- `@typescript-eslint/consistent-type-definitions: ["error", "interface"]` - Prefers interfaces over types
- `import/no-default-export: "error"` - Enforces named exports (with Next.js exceptions)
- `react/jsx-no-leaked-render: ["error", { validStrategies: ["ternary"] }]` - Prefers ternaries over && in JSX

## Utility Libraries
- **@vencura/lib**: Shared utility library for common operations
  - **Async utilities**: `delay`, `fetchWithTimeout`
  - **Error utilities**: `getErrorMessage`, `formatZodError`, `sanitizeErrorMessage`, `isZodError`
  - **Date utilities**: `getDateKey`
  - **Environment utilities**: `validateEnv`, `validateEnvOrThrow`, `getEnvHelper`
  - **Zod utilities**: `formatZodErrors`, `parseJsonWithSchema`
  - Import from `@vencura/lib`: `import { delay, getErrorMessage } from '@vencura/lib'`
  - **Prefer @vencura/lib over custom implementations** for these utilities
  - **Critical**: All @vencura/lib functions MUST return explicit types - consumers should never need type casting
    - ✅ **Good**: `const message = getErrorMessage(error)` (type inferred as `string | null`)
    - ❌ **Bad**: `const message: string | null = getErrorMessage(error)` (redundant - should infer)
    - ❌ **Bad**: `const message = getErrorMessage(error) as string` (should never need casting)
- **Prefer lodash over custom implementations** for common operations
  - Use lodash for array manipulation (`isEmpty`, `uniq`, `groupBy`, `chunk`)
  - Use lodash for object operations (`merge`, `pick`, `omit`, `isEmpty`)
  - Use lodash for type checking (`isString`, `isNumber`, `isEmpty`, `isPlainObject`)
  - Use lodash for string transformations (`camelCase`, `kebabCase`, `startCase`)
  - Use lodash for functional utilities (`debounce`, `throttle`, `memoize`)
  - Import specific functions: `import { isEmpty, uniq } from 'lodash'`
- **Use zod for schema validation** (except NestJS DTOs which use class-validator)
  - All schemas should use zod for runtime validation and type inference
  - NestJS DTOs are the exception - they correctly use `class-validator` per NestJS conventions
  - Use zod for environment variables, API responses, form validation, and tool parameters
  - **Environment Variables**: Always use zod for env validation with `validateEnv` from `@vencura/lib`
    - Define env schema with zod: `const envSchema = z.object({ ... })`
    - Use `validateEnv({ schema: envSchema })` for validation
    - Infer types: `type Env = z.infer<typeof envSchema>`
    - All apps (Next.js, NestJS) should follow the same pattern
  - **Validation Functions**: Zod-based validation functions that return result objects must handle all errors gracefully
    - ✅ **Good**: Return `{ valid: boolean; error?: string }` for all error cases (Zod errors and unexpected errors)
    - ✅ **Good**: Use `isZodError` from `@vencura/lib` to check error types, then return consistent error objects
    - ❌ **Bad**: Rethrowing non-Zod errors breaks callers that expect result objects
    - **Example**: `validateAddressInput` returns `{ valid: false, error: '...' }` for all errors, never throws
    - **Exception**: Library functions designed to throw (e.g., `parseJsonWithSchema`) are fine - they're documented to throw

## ts-reset Type Safety

This monorepo uses `@total-typescript/ts-reset` to enhance TypeScript's built-in type safety. The following changes apply automatically:

- **`JSON.parse()` returns `unknown`**: Always validate parsed JSON data before use
  - ✅ **Good**: `const data = mySchema.parse(JSON.parse(jsonString))` (validate with zod)
  - ✅ **Good**: `const data = JSON.parse(jsonString) as Record<string, unknown>` (type assertion for test utilities)
  - ❌ **Bad**: `const data = JSON.parse(jsonString); const value = data.property` (TypeScript error: property doesn't exist on unknown)

- **`fetch().json()` returns `unknown`**: Always validate API responses before use
  - ✅ **Good**: `const data = await response.json(); const validated = mySchema.parse(data)` (validate with zod)
  - ✅ **Good**: `const data = (await response.json()) as Record<string, unknown>` (type assertion for test utilities)
  - ❌ **Bad**: `const data = await response.json(); const value = data.property` (TypeScript error: property doesn't exist on unknown)

- **`.filter(Boolean)` correctly filters falsy values**: Returns properly typed array without `undefined`, `null`, `false`, `0`, `NaN`, `""`
  - ✅ **Good**: `const numbers = [1, 2, undefined, 3].filter(Boolean)` (type: `number[]`)

- **`.includes()` on `as const` arrays**: Less strict type checking for array includes operations

**Best Practice**: Since `JSON.parse()` and `response.json()` return `unknown`, always validate with zod schemas. This aligns with the monorepo's zod-first approach and ensures type safety at runtime.

## Error Handling
- Fail fast: Handle errors early using guard clauses & early returns
- Place the happy path last for improved readability
- Avoid unnecessary else statements; prefer `if-return` pattern
- Throw errors from `@repo/errors` for consistency
- **Zod-based validation functions**: Functions that return result objects (e.g., `{ valid: boolean; error?: string }`) must catch all errors and return consistent error objects instead of throwing
  - ✅ **Good**: `catch (error) { if (isZodError(error)) return { valid: false, error: ... }; return { valid: false, error: 'Unexpected validation error' } }`
  - ❌ **Bad**: `catch (error) { if (isZodError(error)) return { valid: false, error: ... }; throw error }` (breaks callers expecting result objects)
  - This ensures callers can safely check `.valid` without try/catch blocks

## File Structure & Organization
Maintain a structured and logical order when organizing files:
1. Main Component – The primary component that orchestrates logic and renders subcomponents
2. Subcomponents – Smaller, reusable components that support the main component
3. Helpers & Utilities – Functions or modules that provide reusable logic and utilities
4. Static Content – Non-code assets such as constants, images, or localization files
5. Types & Interfaces – Type definitions for TypeScript to ensure type safety and maintain consistency

## Related Rules
- See [React Rules](../frontend/react.mdc) for React-specific patterns
- See [React Hooks Rules](../frontend/react-hooks.mdc) for hooks and data fetching patterns
- See [Next.js Rules](../frontend/nextjs.mdc) for Next.js-specific patterns